--source include/master-slave.inc
connection master;

################################################################################
###
### Test of document path of document type
###

--disable_warnings
drop view if exists v1;
drop table if exists t1, t2, t3, t4, t5, t6, t7, t8;
--enable_warnings

SET @start_allow_document_type = @@global.allow_document_type;
SELECT @start_allow_document_type;

################################################################################
###
### t1 and t2 : populate data
###

--echo ##### Create tables t1 and t2 and populate data

CREATE TABLE t1 (
       a int not null,
       b char (10) not null,
       doc document not null) engine=innodb;

insert into t1 values (1,'@1','{ "id":101, "name":"Alex", "phone":6507770001, "address":{ "houseNumber":1001, "streetName":"1st", "zipcode":98761, "state":"CA" }, "intstr":"1001", "dt":"1001" }');
insert into t1 values (2,'@2','{ "id":102, "name":"Bob", "phone":6507770002, "address":{ "houseNumber":1002, "streetName":"2nd", "zipcode":98762, "state":"AZ" }, "int64":2222222220123456789, "intstr":"1002", "dt":"0123456789ABCDEFGHIGKLMNOPQRSTUVWXYZ0123456789" }');
insert into t1 values (3,'@3','{ "id":103, "name":"Charlie", "phone":6507770003, "address":{ "houseNumber":1003, "streetName":"3rd", "zipcode":98763, "state":"NY" }, "double":3.94065645841246, "dt":"2014-11-01" }');
insert into t1 values (4,'@1','{ "id":104, "name":"Don", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" }, "Children":["Alex", "Bob", "Charlei"] }');
insert into t1 values (5,'@2','{ "id":105, "name":"Evan", "phone":6507770005, "address":{ "houseNumber":1005, "streetName":"5th", "zipcode":98765, "state":"WA" }, "dt":"2014-11-11 11:59:59" }');
insert into t1 values (8,'@1','{ "id":108, "address":{ "zipcode":98768 } }');
insert into t1 values (7,'@3','{ "id":107, "address":{ "zipcode":98767, "state":"NY" } }');
insert into t1 values (6,'@2','{ "id":106, "address":{ "zipcode":98766 } }');
insert into t1 values (9,'@1','{ "id":109, "name":"Linda", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" } }');


CREATE TABLE t2 (
       a2 int not null,
       b2 char (10) not null,
       doc2 document not null) engine=innodb;

insert into t2 values (10,'@3','{ "id":105, "name":"Alex II", "phone":6507770001, "address":{ "houseNumber":1001, "streetName":"1st", "zipcode":98761, "state":"CA" } }');
insert into t2 values (8,'@1','{ "id":108, "name":"Bob II", "phone":6507770002, "address":{ "houseNumber":1002, "streetName":"2nd", "zipcode":98762, "state":"AZ" } }');
insert into t2 values (3,'@3','{ "id":104, "name":"Charlie II", "phone":6507770003, "address":{ "houseNumber":1003, "streetName":"3rd", "zipcode":98763, "state":"NY" } }');
insert into t2 values (5,'@2','{ "id":106, "name":"Don II", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" }, "Children":["Alex", "Bob", "Charlei"] }');

################################################################################
###
### t3 : big values
###
### The max size is 1100 characters, which is greater than the default sort field length 1024
### so it will be truncated when it is the sorting key in order by clause
###

--echo ##### Create tables t3 with big values

CREATE TABLE t3 (
       a int not null,
       b char (10) not null,
       doc document not null) engine=innodb;

insert into t3 values (3,'@3','{ "id":"3333", "name":"Charlie" }');
insert into t3 values (1,'@1','{ "id":"1", "name":"Alex" }');
insert into t3 values (4,'@4','{ "id":"44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444", "name":"Don" }');

insert into t3 values (2,'@2','{ "id":"22", "name":"Bob" }');

################################################################################
###
### t4 : backtick quoted column name with special characters
###
### TODO: \t
###

--echo ##### Create tables t4 with backtick quoted column name with special characters

CREATE TABLE t4 (
       `~!@#$%^&*()_+-=:;'"<>?,./\t` document not null) engine=innodb;

### \" is not allowed in json key
insert into t4 values ('{"k1":"v1"}');
insert into t4 values ('{"~!@#$%^&*()_+-=:;\'<>?,./":{"~!@#$%^&*()_+-=:;\'<>?,./":"v2"}}');
insert into t4 values ('{"k3":"v3"}');
insert into t4 values ('{"k4":"v4"}');

CREATE TABLE t5 (
       a int not null,
       b char (10) not null,
       doc document not null,
       doc2 document not null) engine=innodb;
insert into t5 values (1,'@1','{ "id":101, "name":"Alex II", "phone":6507770001, "address":{ "houseNumber":1001, "streetName":"1st", "zipcode":98761, "state":"CA" } }','{ "id":204, "name":"Alex II", "phone":6507770001, "address":{ "houseNumber":1001, "streetName":"1st", "zipcode":98761, "state":"CA" } }');
insert into t5 values (2,'@2','{ "id":102, "name":"Bob II", "phone":6507770002, "address":{ "houseNumber":1002, "streetName":"2nd", "zipcode":98762, "state":"AZ" } }','{ "id":203, "name":"Bob II", "phone":6507770002, "address":{ "houseNumber":1002, "streetName":"2nd", "zipcode":98762, "state":"AZ" } }');
insert into t5 values (3,'@3','{ "id":103, "name":"Charlie II", "phone":6507770003, "address":{ "houseNumber":1003, "streetName":"3rd", "zipcode":98763, "state":"NY" } }','{ "id":202, "name":"Charlie II", "phone":6507770003, "address":{ "houseNumber":1003, "streetName":"3rd", "zipcode":98763, "state":"NY" } }');
insert into t5 values (4,'@4','{ "id":104, "name":"Don II", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" }, "Children":["Alex", "Bob", "Charlei"] }','{ "id":201, "name":"Don II", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" }, "Children":["Alex", "Bob", "Charlei"] }');
insert into t5 values (5, '@5', '{"x0":[100, 200, 300]}', '{}');

select `~!@#$%^&*()_+-=:;'"<>?,./\t`
from t4;

select `~!@#$%^&*()_+-=:;'"<>?,./\t`.`~!@#$%^&*()_+-=:;'<>?,./`.`~!@#$%^&*()_+-=:;'<>?,./`
from t4
where `~!@#$%^&*()_+-=:;'"<>?,./\t`.`~!@#$%^&*()_+-=:;'<>?,./`.`~!@#$%^&*()_+-=:;'<>?,./` like "v2";

# FIXME: Cannot specify document default value in CREATE TABLE yet
--error ER_BLOB_CANT_HAVE_DEFAULT
CREATE TABLE t6 (
       a int not null,
       doc document,
       doc2 document not null default '{"foo":"bar"}'
) engine=innodb;

CREATE TABLE t6 (
       a int not null,
       doc document,
       doc2 document not null
) engine=innodb;

# Test the non-null property of document column
--error ER_BAD_NULL_ERROR
insert into t6 values (1, '{}', NULL);
# FIXME: Explicit default should be supported
--error ER_BLOB_CANT_HAVE_DEFAULT
alter table t6 alter doc2 set default '{"No":"Default allowed"}';

# Insert explicit default for non-null column
insert into t6 values (1, NULL, '{}');
insert into t6 (a, doc) values (1, NULL);
insert into t6 (doc) values ('{"k":"v"}');
select * from t6;

# FIXME: Test changing default value
--error ER_BLOB_CANT_HAVE_DEFAULT
alter table t6 alter doc2 set default '{"a":"b"}';
insert into t6 (doc) values ('[]');
select * from t6;

# Inserting implicit null column
insert into t6 (a) values (100);
select * from t6;

# FIXME: Drop default value and test implicit {} as default again
--error ER_BLOB_CANT_HAVE_DEFAULT
alter table t6 alter doc2 drop default;
insert into t6 (a) values (200); 
select * from t6;

# Test UPDATE to null of null/non-null columns
update t6 set doc = null;
select * from t6;
update t6 set doc2 = null;
select * from t6;

drop table t6;

# FIXME: Allow explicit default values for documents to test indexes
CREATE TABLE t6 (
       a int not null,
       doc2 document not null, #default '{"a":1}',
       doc3 document not null, #default '{"a":1}',
       key doc2_a         (doc2.a as int),
       unique key doc3_a  (doc3.a as int)
) engine=innodb;

insert into t6 (a) values (100);
# FIXME: The default value should conflict with the unique index but explicit defaults are not supported
#--error ER_DUP_ENTRY
insert into t6 (a) values (100);
insert into t6 (doc3) values ('{}');
insert into t6 (doc2, doc3) values ('{}', '{}');
select * from t6;

drop table t6;

# Test backticks around document path keys
select doc.address.state from t5;
select doc.`address`.state from t5;
select doc.address.`state` from t5;
select doc.`address`.`state` from t5;
select `doc`.address.state from t5;
select `doc`.`address`.state from t5;
select `doc`.address.`state` from t5;
select `doc`.`address`.`state` from t5;

# Test backticks around document path array index at end
select doc.Children.0 from t5;
select doc.`Children`.0 from t5;
select doc.Children.`0` from t5;
select doc.`Children`.`0` from t5;
select `doc`.Children.0 from t5;
select `doc`.`Children`.0 from t5;
select `doc`.Children.`0` from t5;
select `doc`.`Children`.`0` from t5;

# Test backticks around document path array index before key
select doc.0.foo from t5;
select doc.0.`foo` from t5;
select doc.`0`.foo from t5;
select doc.`0`.`foo` from t5;
select `doc`.0.foo from t5;
select `doc`.0.`foo` from t5;
select `doc`.`0`.foo from t5;
select `doc`.`0`.`foo` from t5;

# Test backticks around document path where key name ends with digit
select doc.x0.1 from t5;
select `doc`.x0.1 from t5;
select doc.`x0`.1 from t5;
select doc.x0.`1` from t5;
select `doc`.`x0`.1 from t5;
select `doc`.x0.`1` from t5;
select doc.`x0`.`1` from t5;
select `doc`.`x0`.`1` from t5;

################################################################################
###
### The original cases: database.table.field, table.field and .table.field
###

--echo ##### When document type is disabled, the original cases of database.table.field, table.field and .table.field

### Disable document type to make parser work as before
SET @@global.allow_document_type = false;
SELECT @@global.allow_document_type;

### The original cases 1: database.table.field
select test.t1.b from test.t1 where test.t1.a = 1;

### The original cases 2: table.field
select t1.doc from test.t1 where t1.a = 2;

### The original cases 3: .table.field
select .t1.doc from test.t1 where .t1.a = 4;


################################################################################
###
### When document type is disabled, all the new syntax will be treated as errors
###

--echo ##### When document type is disabled, all the new syntax will be treated as errors

--error ER_INVALID_FIELD_OR_REFERENCE
select test.t1.doc.address.houseNumber from t1 where t1.a = 3;

--error ER_INVALID_FIELD_OR_REFERENCE
select a from t1 where test.t1.doc.id = 102;

--error ER_INVALID_FIELD_OR_REFERENCE
select test.t1.doc.address.houseNumber from t1 where test.t1.doc.address.zipcode = 98762;

### Enable document type with the new parsing logic
SET @@global.allow_document_type = true;
SELECT @@global.allow_document_type;

### All the three original cases work as before
select test.t1.b from test.t1 where test.t1.a = 1;
select t1.doc from test.t1 where t1.a = 2;
select .t1.doc from test.t1 where .t1.a = 4;


################################################################################
###
### Invalid document path: using document path on a non-document column
###

--echo ##### Invalid document path when using document path on a non-document column

### Disable document type to make parser work as before
SET @@global.allow_document_type = false;
SELECT @@global.allow_document_type;

--error ER_BAD_FIELD_ERROR
select b.k1 from t1;
--error ER_BAD_FIELD_ERROR
select b.k1.k2 from t1;
--error ER_INVALID_FIELD_OR_REFERENCE
select b.k1.k2.k3 from t1;

### Enable document type with the new parsing logic
SET @@global.allow_document_type = true;
SELECT @@global.allow_document_type;

## In SELECT
--error ER_BAD_FIELD_ERROR
select b.k1 from t1;
--error ER_BAD_FIELD_ERROR
select b.k1.k2 from t1;
--error ER_BAD_FIELD_ERROR
select b.k1.k2.k3 from t1;

## In WHERE
--error ER_BAD_FIELD_ERROR
select a from t1 where b.k1 = 100;
--error ER_BAD_FIELD_ERROR
select a from t1 where b.k1.k2 = 100;
--error ER_BAD_FIELD_ERROR
select a from t1 where b.k1.k2.k3 = 100;

## In ORDER BY
--error ER_BAD_FIELD_ERROR
select a from t1 order by b.k1;
--error ER_BAD_FIELD_ERROR
select a from t1 order by b.k1.k2 ;
--error ER_BAD_FIELD_ERROR
select a from t1 order by b.k1.k2.k3;

## In GROUP BY
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by b.k1;
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by b.k1.k2;
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by b.k1.k2.k3;

## In HAVING
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by a having b.k1 = 100;
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by a having b.k1.k2 = 100;
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by a having b.k1.k2.k3 = 100;

## In HAVING without GROUP BY then HAVING clause behaves like WHERE clause
--error ER_BAD_FIELD_ERROR
select a from t1 having b.k1 = 100;
--error ER_BAD_FIELD_ERROR
select a from t1 having b.k1.k2 = 100;
--error ER_BAD_FIELD_ERROR
select a from t1 having b.k1.k2.k3 = 100;

## In Functions
--error ER_BAD_FIELD_ERROR
select a from t1 where substr(b.k1, 1, 10) like 'abc';
--error ER_BAD_FIELD_ERROR
select a from t1 where substr(b.k1.k2, 1, 10) like 'abc';
--error ER_BAD_FIELD_ERROR
select a from t1 where substr(b.k1.k2.k3, 1, 10) like 'abc';

--error ER_BAD_FIELD_ERROR
select sum(b.k1) from t1 where a = 100;
--error ER_BAD_FIELD_ERROR
select sum(b.k1.k2) from t1 where a = 100;
--error ER_BAD_FIELD_ERROR
select sum(b.k1.k2.k3) from t1 where a = 100;


################################################################################
###
### Document path with different types in SELECT clause (with and without aliases)
###

--echo ##### Document path with different types in SELECT clause

### Document path in SELECT clause: database.table.field.key1, in which key1 does not exist
### Expecting empty string
select test.t1.doc.NonExistent from t1 where t1.a = 4;
select test.t1.doc.NonExistent as NonExistent from t1 where t1.a = 4;

### Regular document field in SELECT clause: database.table.field
select test.t1.doc from t1 where t1.a = 3;
select test.t1.doc as doc from t1 where t1.a = 3;

### Document path in SELECT clause: database.table.field.key1.key2 that points to an int16
select test.t1.doc.address.houseNumber from t1 where t1.a = 3;
select test.t1.doc.address.houseNumber as houseNumber from t1 where t1.a = 3;

### Document paths in SELECT clause: database.table.field.key1 that points to an int64
select test.t1.doc.int64 from t1 where t1.a = 2;
select test.t1.doc.int64 as int64 from t1 where t1.a = 2;

### Document paths in SELECT clause: database.table.field.key1 that points to an double
select test.t1.doc.double from t1 where t1.a = 3;
select test.t1.doc.double as dble from t1 where t1.a = 3;

### Document paths in SELECT clause: database.table.field.key1 that points to an string
select test.t1.doc.name from t1 where t1.a = 3;
select test.t1.doc.name as name from t1 where t1.a = 3;

### Document paths in SELECT clause: database.table.field.key1.array_index that points to an string
### FBSon array index is 0-based
select test.t1.doc.Children.0 from t1 where t1.a = 4;
select test.t1.doc.Children.1 from t1 where t1.a = 4;
select test.t1.doc.Children.2 from t1 where t1.a = 4;
select test.t1.doc.Children.0 as Children0 from t1 where t1.a = 4;

### Document paths in function in SELECT clause
select abs(test.t1.doc.double), abs(test.t1.doc.double - 3.94065645841245) from t1 where a = 3;
select abs(test.t1.doc.double) as abs1, abs(test.t1.doc.double - 3.94065645841245) as abs2
from t1
where a = 3;

### Document paths in SELECT clause: database.table.field.key1 that points to an JSON object
select test.t1.doc.address from t1 where t1.a = 3;
select test.t1.doc.address as address from t1 where t1.a = 3;

### Document paths in SELECT clause: database.table.field.key1 that points to an JSON array
select test.t1.doc.Children from t1 where t1.a = 4;
select test.t1.doc.Children as Children from t1 where t1.a = 4;

### Document paths in SELECT clause: table.field.key1 that needs right shift for one during fixing
select t1.doc.address.houseNumber from t1 where t1.a = 4;
select t1.doc.address.houseNumber as houseNumber from t1 where t1.a = 4;

### Document paths in SELECT clause: field.key1.key2 that needs right shift for two during fixing
select doc.address.houseNumber from t1 where t1.a = 4;
select doc.address.houseNumber as houseNumber from t1 where t1.a = 4;


################################################################################
###
### Document paths with different types in WHERE clause
###

--echo ##### Document paths with different types in WHERE clause

### Document paths in WHERE clause: database.table.field.key1, in which key1 does not exist
### Expecting empty result
select a from t1 where test.t1.doc.NonExistent = 102;

### Document paths in WHERE clause: database.table.field.key1 = int,
### the document paths value will be retrived as real
select a from t1 where test.t1.doc.id = 102;

### int64
select a from t1 where test.t1.doc.int64 = 2222222220123456789;

### Use document paths in function in WHERE clause
### Use threshold to deal with the precision issue when comparing two doubles
select a from t1 where abs(test.t1.doc.double - 3.94065645841246) < 0.0000001;

### Same document paths appears in both SELECT and WHERE clause
select t1.doc.id from t1 where t1.doc.id > 101 and t1.doc.id < 104;

### string
select a from t1 where test.t1.doc.name like "Bob";

select a from t1 where substring(test.t1.doc.name, 1, 2) like "Bo";

### cast as unsigned
select a from t1 where cast(test.t1.doc.id as unsigned) = 102;

select a from t1 where cast(test.t1.doc.intstr as unsigned) = 1002;

### cast as char
select a from t1 where cast(test.t1.doc.id as char) like "102";

### cast as date
select test.t1.doc.dt from t1 where cast(test.t1.doc.dt as date) = cast('2014-11-01' as date);

### cast as datetime
select test.t1.doc.dt from t1 where cast(test.t1.doc.dt as datetime) = cast('2014-11-11 11:59:59' as datetime);

### cast as timestamp
select test.t1.doc.dt from t1 where cast(test.t1.doc.dt as time) = cast('2014-11-11 11:59:59' as time);

### Document path in both SELECT and WHERE clause: database.table.field.key1.key2
select test.t1.doc.address.houseNumber from t1 where test.t1.doc.address.zipcode = 98762;

### Document paths in WHERE clause for UPDATE statements
select t1.a, t1.b from t1 where doc.address.zipcode = 98761;
update t1 set t1.a = 101, t1.b = '@101' where doc.address.zipcode = 98761;
select t1.a, t1.b from t1 where doc.address.zipcode = 98761;
update t1 set t1.a = 1, t1.b = '@1' where doc.address.zipcode = 98761;
select t1.a, t1.b from t1 where doc.address.zipcode = 98761;

################################################################################
###
### Document paths with different types in views using MERGE algorithm
###

--echo ##### Document path with different types in views using MERGE algorithm

### Test expected errors/failures from views with doc paths
--error ER_DUP_FIELDNAME
create algorithm = merge view v1 as
select doc.id, doc.id from t1;

--error ER_DUP_FIELDNAME
create algorithm = merge view v1 as
select doc, doc from t1;

--error ER_DUP_FIELDNAME
create algorithm = merge view v1 as
select doc.id, doc, doc.id from t1;

--error ER_DUP_FIELDNAME
create algorithm = merge view v1 as
select doc, doc.id, doc from t1;

--error ER_BAD_FIELD_ERROR
create algorithm = merge view v1 as
select doc123.id from t1;

create algorithm = merge view v1 as
select doc.address from t1;
select doc.address.id from v1;
drop view v1;

create algorithm = merge view v1 as
select doc.address as addr from t1;
select addr from v1;
drop view v1;

create algorithm = merge view v1 as
select doc.address as addr from t1;
select addr.zipcode from v1;
drop view v1;

create algorithm = merge view v1 as
select doc from t1;
select doc.address.zipcode from v1;
drop view v1;

create algorithm = merge view v1 (addr) as
select doc.address from t1;
select addr.zipcode from v1;
drop view v1;

### Test view with int as doc path
create algorithm = merge view v1 as
select doc.id from t1;
select * from v1;
drop view v1;

### Test view with int as doc path and use alias
create algorithm = merge view v1 (row1) as
select doc.id from t1;
select row1 from v1;
drop view v1;

### Test view with char as doc path
create algorithm = merge view v1 as
select doc.address.state from t1;
select * from v1;
drop view v1;

### Test view with char as doc path and use alias
create algorithm = merge view v1 (row1) as
select doc.address.state from t1;
select row1 from v1;
drop view v1;

### Test view with JSON object converted to string
create algorithm = merge view v1 as
select doc.address from t1;
select * from v1;
drop view v1;

### Test view with JSON object converted to string and use alias
create algorithm = merge view v1 (row1) as
select doc.address from t1;
select row1 from v1;
drop view v1;

### Test view with doc column
create algorithm = merge view v1 as
select doc from t1;
select * from v1;
drop view v1;

### Test view with doc column and use alias
create algorithm = merge view v1 (row1) as
select doc from t1;
select row1 from v1;
drop view v1;

### Test view with multiple doc paths/doc columns in definition
create algorithm = merge view v1 as
select doc.address.state, doc.id, doc from t1;
select * from v1;
drop view v1;

create algorithm = merge view v1 as
select doc, doc.address.state, doc.id from t1;
select * from v1;
drop view v1;

create algorithm = merge view v1 as
select doc.address.state, doc, doc.id from t1;
select * from v1;
drop view v1;

### Test view with multiple doc paths/doc columns and use aliases
create algorithm = merge view v1 (row1, row2, row3) as
select doc.address.state, doc.id, doc from t1;
select row1 from v1;
drop view v1;

create algorithm = merge view v1 (row1, row2, row3) as
select doc.address.state, doc.id, doc from t1;
select row1, row3 from v1;
drop view v1;

create algorithm = merge view v1 (row1, row2, row3) as
select doc.address.state, doc.id, doc from t1;
select row1, row2, row3 from v1;
drop view v1;

create algorithm = merge view v1 (row1, row2, row3) as
select doc, doc.address.state, doc.id from t1;
select row1 from v1;
drop view v1;

create algorithm = merge view v1 (row1, row2, row3) as
select doc, doc.address.state, doc.id from t1;
select row1, row3 from v1;
drop view v1;

create algorithm = merge view v1 (row1, row2, row3) as
select doc, doc.address.state, doc.id from t1;
select row1, row2, row3 from v1;
drop view v1;

create algorithm = merge view v1 (row1, row2, row3) as
select doc.address.state, doc, doc.id from t1;
select row1 from v1;
drop view v1;

create algorithm = merge view v1 (row1, row2, row3) as
select doc.address.state, doc, doc.id from t1;
select row1, row3 from v1;
drop view v1;

create algorithm = merge view v1 (row1, row2, row3) as
select doc.address.state, doc, doc.id from t1;
select row1, row2, row3 from v1;
drop view v1;

### Test order by/group by inside views
create algorithm = merge view v1 as
select doc.address.state, doc.id from t1 order by doc.address.state, a;
select * from v1;
drop view v1;

create algorithm = merge view v1 as
select doc.address.state, doc.id from t1 order by doc.id;
select * from v1;
drop view v1;

create algorithm = merge view v1 as
select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char);
select * from v1;
drop view v1;

create algorithm = merge view v1 as
select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char);
select * from v1;
drop view v1;

### Test view prefixes on selects
create algorithm = merge view v1 (row1, row2, row3) as
select doc.address.state, doc, doc.id from t1;
select v1.row1 from v1;
select v1.row2 from v1;
select v1.row3 from v1;
drop view v1;

create algorithm = temptable view v1 as
select doc.id from t1;
select * from v1;
drop view v1;

create table t8 (
   doc document not null) engine = innodb;

insert into t8 values('{"k1":{"k2":{"k3":{"k4":123}}}}');
create algorithm = merge view v1 as
select doc.k1.k2 from t8;
create algorithm = merge view v2 as
select doc.k1.k2.k3.k4 from v1;
select * from v2;
drop view v1, v2;
drop table t8;

################################################################################
###
### Document paths with different types in views using TEMPTABLE algorithm
###

--echo ##### Document path with different types in views using TEMPTABLE algorithm

### Test expected errors/failures from views with doc paths
--error ER_DUP_FIELDNAME
create algorithm = temptable view v1 as
select doc.id, doc.id from t1;

--error ER_DUP_FIELDNAME
create algorithm = temptable view v1 as
select doc, doc from t1;

--error ER_DUP_FIELDNAME
create algorithm = temptable view v1 as
select doc.id, doc, doc.id from t1;

--error ER_DUP_FIELDNAME
create algorithm = temptable view v1 as
select doc, doc.id, doc from t1;

--error ER_BAD_FIELD_ERROR
create algorithm = temptable view v1 as
select doc123.id from t1;

create algorithm = temptable view v1 as
select doc.address from t1;
select doc.address.id from v1;
drop view v1;

create algorithm = temptable view v1 as
select doc.address as addr from t1;
select addr from v1;
drop view v1;

create algorithm = temptable view v1 as
select doc.address as addr from t1;
select addr.zipcode from v1;
drop view v1;

create algorithm = temptable view v1 as
select doc from t1;
select doc.address.zipcode from v1;
drop view v1;

create algorithm = temptable view v1 (addr) as
select doc.address from t1;
select addr.zipcode from v1;
drop view v1;

### Test view with int as doc path
create algorithm = temptable view v1 as
select doc.id from t1;
select * from v1;
drop view v1;

### Test view with int as doc path and use alias
create algorithm = temptable view v1 (row1) as
select doc.id from t1;
select row1 from v1;
drop view v1;

### Test view with char as doc path
create algorithm = temptable view v1 as
select doc.address.state from t1;
select * from v1;
drop view v1;

### Test view with char as doc path and use alias
create algorithm = temptable view v1 (row1) as
select doc.address.state from t1;
select row1 from v1;
drop view v1;

### Test view with JSON object converted to string
create algorithm = temptable view v1 as
select doc.address from t1;
select * from v1;
drop view v1;

### Test view with JSON object converted to string and use alias
create algorithm = temptable view v1 (row1) as
select doc.address from t1;
select row1 from v1;
drop view v1;

### Test view with doc column
create algorithm = temptable view v1 as
select doc from t1;
select * from v1;
drop view v1;

### Test view with doc column and use alias
create algorithm = temptable view v1 (row1) as
select doc from t1;
select row1 from v1;
drop view v1;

### Test view with multiple doc paths/doc columns in definition
create algorithm = temptable view v1 as
select doc.address.state, doc.id, doc from t1;
select * from v1;
drop view v1;

create algorithm = temptable view v1 as
select doc, doc.address.state, doc.id from t1;
select * from v1;
drop view v1;

create algorithm = temptable view v1 as
select doc.address.state, doc, doc.id from t1;
select * from v1;
drop view v1;

### Test view with multiple doc paths/doc columns and use aliases
create algorithm = temptable view v1 (row1, row2, row3) as
select doc.address.state, doc.id, doc from t1;
select row1 from v1;
drop view v1;

create algorithm = temptable view v1 (row1, row2, row3) as
select doc.address.state, doc.id, doc from t1;
select row1, row3 from v1;
drop view v1;

create algorithm = temptable view v1 (row1, row2, row3) as
select doc.address.state, doc.id, doc from t1;
select row1, row2, row3 from v1;
drop view v1;

create algorithm = temptable view v1 (row1, row2, row3) as
select doc, doc.address.state, doc.id from t1;
select row1 from v1;
drop view v1;

create algorithm = temptable view v1 (row1, row2, row3) as
select doc, doc.address.state, doc.id from t1;
select row1, row3 from v1;
drop view v1;

create algorithm = temptable view v1 (row1, row2, row3) as
select doc, doc.address.state, doc.id from t1;
select row1, row2, row3 from v1;
drop view v1;

create algorithm = temptable view v1 (row1, row2, row3) as
select doc.address.state, doc, doc.id from t1;
select row1 from v1;
drop view v1;

create algorithm = temptable view v1 (row1, row2, row3) as
select doc.address.state, doc, doc.id from t1;
select row1, row3 from v1;
drop view v1;

create algorithm = temptable view v1 (row1, row2, row3) as
select doc.address.state, doc, doc.id from t1;
select row1, row2, row3 from v1;
drop view v1;

### Test order by/group by inside views
create algorithm = temptable view v1 as
select doc.address.state, doc.id from t1 order by doc.address.state, a;
select * from v1;
drop view v1;

create algorithm = temptable view v1 as
select doc.address.state, doc.id from t1 order by doc.id;
select * from v1;
drop view v1;

create algorithm = temptable view v1 as
select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char);
select * from v1;
drop view v1;

create algorithm = temptable view v1 as
select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char);
select * from v1;
drop view v1;

### Test view prefixes on selects
create algorithm = temptable view v1 (row1, row2, row3) as
select doc.address.state, doc, doc.id from t1;
select v1.row1 from v1;
select v1.row2 from v1;
select v1.row3 from v1;
drop view v1;

create table t8 (
   doc document not null) engine = innodb;

insert into t8 values('{"k1":{"k2":{"k3":{"k4":123}}}}');
create algorithm = temptable view v1 as
select doc.k1.k2 from t8;
create algorithm = temptable view v2 as
select doc.k1.k2.k3.k4 from v1;
select * from v1;
drop view v1, v2;
drop table t8;

################################################################################
###
### Document paths with different types in ORDER BY clause (with aliases and positions)
###

--echo ##### Document paths with different types in ORDER BY clause (with and without aliases)

### Document paths in ORDER BY clause: database.table.field.key1, in which key1 does not exist
### the results won't be sorted
select a from t1 order by test.t1.doc.NonExistent, a;
select a from t1 order by cast(t1.doc.NonExistent as unsigned), a;

### use cast to make it sorted as unsigned
select test.t1.doc.id, a from t1 order by cast(test.t1.doc.id as unsigned);
select test.t1.doc.id, a from t1 order by cast(test.t1.doc.id as unsigned) desc;
select test.t1.doc.id, a from t1 order by 1 desc;

select test.t1.doc.address.zipcode, a from t1 order by cast(test.t1.doc.address.zipcode as signed), 2;
select test.t1.doc.address.zipcode, a from t1 order by cast(test.t1.doc.address.zipcode as char) desc, 2;

### use alias for the whole cast function
select cast(test.t1.doc.address.zipcode as signed), a
from t1
order by cast(test.t1.doc.address.zipcode as signed), a;

select cast(test.t1.doc.address.zipcode as signed) as zipcode, a
from t1
order by zipcode, a;

select cast(test.t1.doc.address.zipcode as char), a
from t1
order by cast(test.t1.doc.address.zipcode as char) desc, a;

select cast(test.t1.doc.address.zipcode as char), a
from t1
order by 1 desc, a;

select cast(test.t1.doc.address.zipcode as char) as zipcode, a
from t1
order by zipcode desc, a;

select a, cast(test.t1.doc.address.zipcode as char) as zipcode
from t1
order by 2 desc, a;

### use alias of document path within cast function
select a, test.t1.doc.address.state as state
from t1
order by cast(state as char), a;

select a, test.t1.doc.address.state as state
from t1
order by cast(state as char) desc, a;

select a, test.t1.doc.address.zipcode as zipcode
from t1
order by cast(zipcode as char), a;

select a, test.t1.doc.address.zipcode as zipcode
from t1
order by cast(zipcode as char) desc, a;

select a, test.t1.doc.address.zipcode as zipcode
from t1
order by cast(zipcode as unsigned), a;

select a, test.t1.doc.address.zipcode as zipcode
from t1
order by cast(zipcode as unsigned) desc, a;

### without cast to make it sorted as string
select test.t1.doc.id, a from t1 order by test.t1.doc.id, a;
select test.t1.doc.id, a from t1 order by t1.doc.id desc, a;

select test.t1.doc.id as id, a from t1 order by id, a;
select test.t1.doc.id as id, a from t1 order by id desc, a;

### big string with length of 1110 won't be truncated
select doc.id, a from t3 order by test.t3.doc.id, a;
select test.t3.doc.id, a from t3 order by t3.doc.id desc, a;
select test.t3.doc.id, a from t3 where a = 4;

### Using hint
CREATE TABLE t8 (
       a int not null,
       b char (10) not null,
       doc document not null) engine=innodb;

insert into t8 values(1, '1', '{"int":1, "int_str":"1", "double":1.1, "double_str":"1.1"}');
insert into t8 values(2, '2', '{"int":2, "int_str":"2", "double":2.2, "double_str":"2.2"}');
insert into t8 values(3, '3', '{"int":3, "int_str":"3", "double":3.3, "double_str":"3.3"}');
insert into t8 values(4, '4', '{"int":4, "int_str":"4", "double":4.4, "double_str":"4.4"}');
insert into t8 values(5, '5', '{"int":5, "int_str":"5", "double":5.5, "double_str":"5.5"}');
insert into t8 values(6, '6', '{"int":6, "int_str":"6", "double":6.6, "double_str":"6.6"}');
insert into t8 values(7, '7', '{"int":7, "int_str":"7", "double":7.7, "double_str":"7.7"}');
insert into t8 values(8, '8', '{"int":8, "int_str":"8", "double":8.8, "double_str":"8.8"}');
insert into t8 values(9, '9', '{"int":9, "int_str":"9", "double":9.9, "double_str":"9.9"}');
insert into t8 values(10, '10', '{"int":10, "int_str":"10", "double":10.1, "double_str":"10.1"}');
insert into t8 values(11, '11', '{"int":11, "int_str":"11", "double":11.11, "double_str":"11.11"}');
insert into t8 values(12, '12', '{"int":12, "int_str":"12", "double":12.12, "double_str":"12.12"}');
insert into t8 values(13, '13', '{"int":13, "int_str":"13", "double":13.13, "double_str":"13.13"}');

select * from t8 order by t8.doc.int;
select * from t8 order by t8.doc.int as string;
select * from t8 order by t8.doc.int as int;
select * from t8 order by t8.doc.int as double;

select * from t8 order by t8.doc.int_str;
select * from t8 order by t8.doc.int_str as string;
select * from t8 order by t8.doc.int_str as int;
select * from t8 order by t8.doc.int_str as double;

select * from t8 order by t8.doc.double;
select * from t8 order by t8.doc.double as string;
select * from t8 order by t8.doc.double as int;
select * from t8 order by t8.doc.double as double;

select * from t8 order by t8.doc.double_str;
select * from t8 order by t8.doc.double_str as string;
select * from t8 order by t8.doc.double_str as int;
select * from t8 order by t8.doc.double_str as double;

--error ER_ORDERBY_AS_TYPE_NOT_SUPPORTED
select * from t8 order by t8.a as string;

truncate table t8;
insert into t8 values(1, '1', '{"int":3, "int_str":"3", "double":1.1, "double_str":"1.1"}');
insert into t8 values(2, '2', '{"int":2, "int_str":"2", "double":1.2, "double_str":"2.2"}');
insert into t8 values(3, '3', '{"int":3, "int_str":"3", "double":3.3, "double_str":"3.3"}');
select * from t8 order by t8.doc.double as int, t8.doc.int_str as int;
drop table t8;
### without NULL values

### document path is the only SELECT time
select test.t1.doc.address.zipcode from t1 order by test.t1.doc.address.zipcode;
select test.t1.doc.address.zipcode from t1 order by t1.doc.address.zipcode desc;

select test.t1.doc.address.zipcode as zipcode from t1 order by zipcode;
select test.t1.doc.address.zipcode as zipcode from t1 order by zipcode desc;

### document path is the last SELECT time
select a, test.t1.doc.address.zipcode from t1 order by test.t1.doc.address.zipcode, a;
select a, test.t1.doc.address.zipcode from t1 order by t1.doc.address.zipcode desc, a;

select a, test.t1.doc.address.zipcode as zipcode from t1 order by zipcode, a;
select a, test.t1.doc.address.zipcode as zipcode from t1 order by zipcode desc, a;

### document path is not the last SELECT time
select test.t1.doc.address.zipcode, a from t1 order by test.t1.doc.address.zipcode, a;
select test.t1.doc.address.zipcode, a from t1 order by t1.doc.address.zipcode desc, a;

select test.t1.doc.address.zipcode as zipcode, a from t1 order by zipcode, a;
select test.t1.doc.address.zipcode as zipcode, a from t1 order by zipcode desc, a;

### with NULL values

### document path is the only SELECT time
select test.t1.doc.address.state from t1 order by test.t1.doc.address.state;
select test.t1.doc.address.state from t1 order by t1.doc.address.state desc;
select test.t1.doc.address.state from t1 order by 1 desc;

select test.t1.doc.address.state as state from t1 order by state;
select test.t1.doc.address.state as state from t1 order by state desc;

### document path is the last SELECT time
select a, test.t1.doc.address.state from t1 order by test.t1.doc.address.state, a;
select a, test.t1.doc.address.state from t1 order by t1.doc.address.state desc, a;

select a, test.t1.doc.address.state as state from t1 order by state, a;
select a, test.t1.doc.address.state as state from t1 order by state desc, a;

### document path is not the last SELECT time
select test.t1.doc.address.state, a from t1 order by test.t1.doc.address.state, a;
select test.t1.doc.address.state, a from t1 order by t1.doc.address.state desc, a;

select test.t1.doc.address.state as state, a from t1 order by state, a;
select test.t1.doc.address.state as state, a from t1 order by state desc, a;

### multiple non-duplicate document paths
select doc.address.state as state, doc.address.zipcode as zipcode, a
from t1
order by state, zipcode, a;

select doc.address.state as state, doc.address.zipcode as zipcode, a
from t1
order by zipcode desc, state desc, a asc;

select doc.address.state as state, doc.address.zipcode as zipcode, doc.name as name, a
from t1
order by zipcode desc, state desc, name desc, a asc;

select a, doc.address.state as state, doc.address.zipcode as zipcode
from t1
order by a desc, state asc, zipcode desc;

select a, doc.address.state, doc.address.zipcode
from t1
order by test.t1.doc.address.zipcode desc, t1.doc.address.state asc, a desc;

select a, doc.address.state, doc.address.zipcode, doc.name
from t1
order by test.t1.doc.address.zipcode desc, t1.doc.address.state asc, doc.name desc, a desc;

select a, doc.address.state, doc.address.zipcode
from t1
order by doc.address.zipcode, doc.address.state, a;

select a, doc.address.state, doc.address.zipcode
from t1
order by doc.address.zipcode, doc.address.state, doc.name, a;

### document field and document paths in ORDER BY without document path in SELECT
select a
from t1
order by doc;

select a
from t1
order by doc desc;

select a
from t1
order by doc, doc.address.state desc, doc.address.zipcode;

### multiple duplicate document paths
select doc.address.state as state, doc.address.zipcode as zipcode, a
from t1
order by state, state, a;

select doc.address.zipcode as zipcode, a
from t1
order by test.t1.doc.address.zipcode, t1.doc.address.zipcode, a asc;

select doc.address.state as state, a
from t1
order by state, test.t1.doc.address.state, a desc;

### test selecting and ordering by different doc paths
select doc.address.zipcode
from t1
order by doc.address.state, a;

select t1.doc.address.zipcode
from t1
order by doc.address.state, a;

select doc.address.state
from t1
order by doc.address.zipcode, a;

select t1.doc.address.state
from t1
order by doc.address.zipcode, a;

### test single doc path in select and order by doc column (and vice-versa)
select doc.address.state
from t1
order by doc;

select doc
from t1
order by doc.address.state, a;

select t1.doc.address.state
from t1
order by doc;

select t1.doc
from t1
order by doc.address.state, a;

### test selecting both doc path and doc column being after single order by
select doc, doc.address.state
from t1
order by doc;

select doc.address.state, doc
from t1
order by doc;

select doc, doc.address.state
from t1
order by doc.address.state, a;

select doc.address.state, doc
from t1
order by doc.address.state, a;

select t1.doc, t1.doc.address.state
from t1
order by doc;

select t1.doc.address.state, t1.doc
from t1
order by doc;

select t1.doc, t1.doc.address.state
from t1
order by doc.address.state, a;

select t1.doc.address.state, t1.doc
from t1
order by doc.address.state, a;

### test selecting one field but order by doc column and doc path
select doc.address.state
from t1
order by doc, doc.address.state;

select doc.address.state
from t1
order by doc.address.state, doc;

select doc
from t1
order by doc, doc.address.state;

select doc
from t1
order by doc.address.state, doc;

select t1.doc.address.state
from t1
order by doc, doc.address.state;

select t1.doc.address.state
from t1
order by doc.address.state, doc;

select t1.doc
from t1
order by doc, doc.address.state;

select t1.doc
from t1
order by doc.address.state, doc;

### test selecting doc path, doc column and order by same doc path, doc column
select doc, doc.address.state
from t1
order by doc, doc.address.state;

select doc.address.state, doc
from t1
order by doc, doc.address.state;

select doc, doc.address.state
from t1
order by doc.address.state, doc;

select doc.address.state, doc
from t1
order by doc.address.state, doc;

select t1.doc, t1.doc.address.state
from t1
order by doc, doc.address.state;

select t1.doc.address.state, t1.doc
from t1
order by doc, doc.address.state;

select t1.doc, t1.doc.address.state
from t1
order by doc.address.state, doc;

select t1.doc.address.state, t1.doc
from t1
order by doc.address.state, doc;

### test selecting a doc path/doc columns and ordering by doc columns and aliases
select doc.address.state as state
from t1
order by doc;

select doc.address.state as state
from t1
order by state, a;

select doc.address.state as state
from t1
order by doc.address.state, a;

select doc as doc2 
from t1
order by doc.address.state, a;

select doc as doc2 
from t1
order by doc2;

select doc as doc2 
from t1
order by doc;

select t1.doc.address.state as state
from t1
order by doc;

select t1.doc.address.state as state
from t1
order by state, a;

select t1.doc.address.state as state
from t1
order by doc.address.state, a;

select t1.doc as doc2 
from t1
order by doc.address.state, a;

select t1.doc as doc2 
from t1
order by doc2;

select t1.doc as doc2 
from t1
order by doc;

### test selecting/ordering different doc paths from different columns of same table
select doc.id
from t5
order by doc2.id;

select t5.doc.id
from t5
order by doc2.id;

select doc2.id
from t5
order by doc.id;

select t5.doc2.id
from t5
order by doc.id;

select doc.id
from t5
order by doc.id;

select doc2.id
from t5
order by doc2.id;

select t5.doc.id
from t5
order by doc.id;

select t5.doc2.id
from t5
order by doc2.id;


################################################################################
###
### Document column in GROUP BY
###

CREATE TABLE t6 (
       a int not null,
       b char (10) not null,
       doc document) engine=innodb;

insert t6 select * from t1;
insert t6 values(0, '@0', null);
insert t6 values(10, '@10', '{ "id":108, "address":{ "zipcode":98768 } }');
insert t6 values(11, '@11', '{ "id":108, "address":{ "zipcode":98768 } }');
insert t6 values(12, '@12', '{ "id":108, "address":{ "zipcode":98768 } }');

select count(*), doc from t6 group by doc;
select count(*), doc.NotExists from t6 group by doc.NotExists;
select count(*), doc.address from t6 group by doc.address;
select count(*), doc.address.state from t6 group by doc.address.state;

select count(doc), doc from t6 group by doc;
select count(doc.NotExists), doc.NotExists from t6 group by doc.NotExists;
select count(doc.address), doc.address from t6 group by doc.address;
select count(doc.address.state), doc.address.state from t6 group by doc.address.state;

drop table t6;

################################################################################
###
### Document paths with different types in GROUP BY without HAVING clause (with aliases and positions)
###

--echo ##### Document paths with different types in GROUP BY without HAVING clause (with and without aliases)

### cast to string
select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char);

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by 2;

select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by state;

select cast(test.t1.doc.address.state as char) as state, count(*)
from t1
group by 1;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char) desc;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by 2 desc;

### Alias of the whole cast function
select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by state desc;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char)
order by cast(test.t1.doc.address.state as char) desc;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by 2
order by 2 desc;

select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by state
order by state desc;

select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by 2
order by 2 desc;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char)
order by cast(test.t1.doc.address.state as char) desc;

select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by state
order by state desc;

# use alias of document path within cast function
select count(*), test.t1.doc.address.state as state
from t1
group by cast(state as char);

select count(*), test.t1.doc.address.state as state
from t1
group by cast(state as char) desc;

select count(*), test.t1.doc.address.state as state
from t1
group by cast(state as char)
order by cast(state as char);

select count(*), test.t1.doc.address.state as state
from t1
group by cast(state as char)
order by cast(state as char) desc;

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by cast(zipcode as char);

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by cast(zipcode as char) desc;

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by cast(zipcode as unsigned)
order by cast(zipcode as unsigned);

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by cast(zipcode as unsigned)
order by cast(zipcode as unsigned) desc;

### use document paths directly with default string type
select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.state;

select count(*), test.t1.doc.address.state as state
from t1
group by state;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.state desc;

select count(*), test.t1.doc.address.state as state
from t1
group by state desc;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.state
order by test.t1.doc.address.state desc;

select count(*), test.t1.doc.address.state
from t1
group by 2
order by 2 desc;

select test.t1.doc.address.state, count(*)
from t1
group by 1
order by 1 desc;

select * from (
select test.t1.doc.address.state, count(*)
from t1
group by 1
order by 1 desc)
as tmp;

select count(*), test.t1.doc.address.state as state
from t1
group by state
order by state desc;

### cast to string
select count(*) as total, test.t1.doc.address.state
from t1
group by cast(test.t1.doc.address.state as char)
having total > 1;

select count(*) as total, test.t1.doc.address.state
from t1
group by cast(test.t1.doc.address.state as char) desc
having total >= 2;

select count(*) as total, test.t1.doc.address.state
from t1
group by cast(test.t1.doc.address.state as char)
having total > 1
order by cast(test.t1.doc.address.state as char) desc;

### use document paths directly with default string type
select count(*) as total, test.t1.doc.address.state
from t1
group by test.t1.doc.address.state
having total >= 2;

select count(*) as total, test.t1.doc.address.state
from t1
group by 2
having total >= 2;

select count(*) as total, test.t1.doc.address.state as state
from t1
group by state
having total >= 2;

select count(*) as total, test.t1.doc.address.state
from t1
group by test.t1.doc.address.state desc
having total > 1;

select test.t1.doc.address.state, count(*) as total
from t1
group by 1 desc
having total > 1;

select count(*) as total, test.t1.doc.address.state as state
from t1
group by state desc
having total > 1;

select count(*) as total, test.t1.doc.address.state
from t1
group by test.t1.doc.address.state
having total >= 2
order by test.t1.doc.address.state desc;

select count(*) as total, test.t1.doc.address.state
from t1
group by 2
having total >= 2
order by 2 desc;

select count(*) as total, test.t1.doc.address.state as state
from t1
group by state
having total >= 2
order by state desc;

select test.t1.doc.address.state as state, count(*) as total
from t1
group by 1
having total >= 2
order by 1 desc;

### Sorted as string and big values will be truncated with warnings
select doc.id, a from t3 group by doc.id;
show warnings;


################################################################################
###
### Document paths with different types in GROUP BY with HAVING clause (with aliases and positions)
###
###

--echo ##### Document paths with different types in GROUP BY with HAVING clause (with and without aliases)

# The fields or document paths in HAVING must be in GROUP BY but don't have to be in SELECT
select count(*), test.t1.doc.address.state
from t1
group by t1.doc.address.zipcode
having doc.address.zipcode = 98761;

### the returned type will be string
select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.state
having test.t1.doc.address.state like "NY";

select count(*), test.t1.doc.address.state
from t1
group by 2
having test.t1.doc.address.state like "NY";

select count(*), doc.address.state
from t1
group by doc.address.state
having test.t1.doc.address.state like "NY";

select count(*), doc.address.state
from t1
group by doc.address.state
having doc.address.state like "NY";

select count(*), t1.doc.address.state
from t1
group by doc.address.state
having test.t1.doc.address.state like "NY";

select count(*), doc.address.state
from t1
group by t1.doc.address.state
having test.t1.doc.address.state like "NY";

select count(*), doc.address.state
from t1
group by t1.doc.address.state
having doc.address.state like "NY";

select count(*), test.t1.doc.address.state as state
from t1
group by state
having state like "NY";

### the returned type will be number
select count(*), test.t1.doc.address.zipcode
from t1
group by test.t1.doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select test.t1.doc.address.zipcode, count(*)
from t1
group by 1
having test.t1.doc.address.zipcode = 98761;

select test.t1.doc.address.zipcode, count(*)
from t1
group by 1
having doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by zipcode
having zipcode = 98761;

select count(*), doc.address.zipcode
from t1
group by doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), t1.doc.address.state
from t1
group by doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having test.t1.doc.address.zipcode = 98768;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having t1.doc.address.zipcode = 98768;

### two document pathes with aliases
select count(*), test.t1.doc.address.state, test.t1.doc.address.zipcode
from t1
group by test.t1.doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state, test.t1.doc.address.zipcode
from t1
group by 3
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state, test.t1.doc.address.zipcode
from t1
group by 3
having doc.address.zipcode = 98761;

select count(*), doc.address.state, doc.address.zipcode
from t1
group by doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state as state, test.t1.doc.address.zipcode as zipcode
from t1
group by state
having state like "NY";

select count(*), test.t1.doc.address.state as state, test.t1.doc.address.zipcode as zipcode
from t1
group by zipcode
having zipcode = 98761;

select count(*), test.t1.doc.address.state as state, test.t1.doc.address.zipcode as zipcode
from t1
group by 3
having zipcode = 98761;

### cast from number to string
select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having cast(test.t1.doc.address.zipcode as char) like '98761';

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having cast(test.t1.doc.address.zipcode as char) like '98768';

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having cast(t1.doc.address.zipcode as char) like '98761';

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having cast(doc.address.zipcode as char) like '98761';

### Big value in HAVING will be truncated to 1024 due to the max length of string temp field
select doc.id, a from t3 group by doc.id having doc.id > 4444444444444444;
show warnings;


################################################################################
###
### General cases with JOIN, ORDER BY, SUB QUERY, etc.
###

--echo ##### General cases with JOIN, ORDER BY, SUB QUERY, etc.

### left join with CAST on document path
select t1.a, t1.doc.address.zipcode, t2.a2, t2.doc2.address.zipcode
from t2 left join t1
on cast(t1.doc.address.zipcode as unsigned) = cast(t2.doc2.address.zipcode as unsigned);

### left join without CAST on document path
select t1.a, t1.doc.address.zipcode, t2.a2, t2.doc2.address.zipcode
from t1, t2
where t1.doc.address.zipcode like t2.doc2.address.zipcode;


### left join with CAST on document path with ORDER BY with CAST
select t1.a, t1.doc.address.zipcode, t2.a2, t2.doc2.address.zipcode
from t2 right join t1
on cast(t1.doc.address.zipcode as unsigned) = cast(t2.doc2.address.zipcode as unsigned)
order by cast(t1.doc.address.zipcode as unsigned) asc, t1.a;


### left join without CAST on document path with ORDER BY without CAST
select t1.a, t1.doc.address.zipcode, t2.a2, t2.doc2.address.zipcode
from t2 right join t1
on t1.doc.address.zipcode like t2.doc2.address.zipcode
order by t1.doc.address.zipcode desc, t1.a, t2.a2;


################################################################################
###
### General cases with JOIN, ORDER BY, SUB QUERY, etc.
###
### FIXME:
###
###   SUB QUERY: without CAST, identical document field name in two tables will cause
###              conflicts on document paths from these tables, and alias doesn't work
###              properly.
###

--echo ##### General cases with JOIN, ORDER BY, SUB QUERY, etc.

### Aliases work well with CAST
select t1_name, t1_zipcode, t2_name, t2_zipcode
from (
  select cast(t1.doc.name as char) as t1_name, cast(t1.doc.address.zipcode as unsigned) as t1_zipcode,
         cast(t2.doc2.name as char) as t2_name, cast(t2.doc2.address.zipcode as unsigned) as t2_zipcode
  from t1, t2
  where cast(t1.doc.address.zipcode as unsigned) = cast(t2.doc2.address.zipcode as unsigned)
) as tmp
where t1_zipcode = 98761 or t2_zipcode = 98762;

### Basic subquery with document path
select tmp.doc.id
from (
  select doc
  from t1
  where t1.a >= 4
) as tmp;

select tmp.doc.id
from (
  select doc
  from t1
  where t1.a >= 4
) as tmp
where tmp.doc.id < 106;

select doc.Children.0
from (
  select a, doc.Children
  from t1
) as tmp where json_contains_key(doc.Children, 0);

### Subquery in order by with alias
select tmp.t1_address.houseNumber, t1_address.zipcode, id
from (
  select t1.doc.address as t1_address,
  t1.doc.id as id
  from t1
  order by t1.doc.id desc
) as tmp
where t1_address.zipcode < 98764;

### Subquery in order by with join
select t1_name, tmp.t1_zipcode, t2_name, t2_zipcode
from (
  select t1.doc.name as t1_name, t1.doc.address.zipcode as t1_zipcode,
  t2.doc2.name as t2_name, t2.doc2.address.zipcode as t2_zipcode
  from t1, t2
  where t1.doc.address.zipcode = t2.doc2.address.zipcode
) as tmp
where t1_zipcode = 98761 or tmp.t2_zipcode = 98762;

### Three layer sub query with order by
select t1_zipcode
from (
  select t1_addr.zipcode as t1_zipcode,
  t1_id, t1_addr
  from (
    select t1.doc.address as t1_addr, t1.doc.id as t1_id
    from t1 order by t1.doc.id desc
  ) as tmp1
) as tmp2;

### Four layer sub query
insert into t1 values(10,'@10','{"id":110, "k1":{"k2":{"k3":{"k4":[1,2,3,4]}}}}');
select t_k3.k4
from (
   select t_k2.k3 as t_k3
   from (select t_k1.k2 as t_k2
            from (
               select doc.k1 as t_k1
               from t1
            ) as tmp1
        ) as tmp2
     ) as tmp3;

### Simple join
select t2.doc2.id, t1.doc.address as addr, t1.doc.name, t2.doc2.name
from t1 inner join
t2 on t2.doc2.id = t1.doc.id;

### Join with subquery document path with document path
select addr.zipcode from (
  select t2.doc2.id, t1.doc.address as addr, t1.doc.name, t2.doc2.name
  from t1
  inner join t2
  on t2.doc2.id = t1.doc.id
) as tmp;

### Join with a general column
CREATE TABLE t7 (doc_id int, a int, name char(100));
insert into t7 values(101, 1, 'Alex'),
                     (102, 2, 'Bob'),
                     (103, 3, 'Charlie'),
                     (104, 4, 'Evan'),
                     (105, 5, 'Linda');

### Join document path with string
select t7.a, t1.a, t1.doc.name, t7.name
from t1
join t7 on t7.name = t1.doc.name;

### Join document path with int
select t7.a, t1.a, t1.doc.name, t7.name
from t1
join t7 on t7.doc_id = t1.doc.id;

drop table t7;
### Sub query with extreme large column
insert into t3 values(6, '@6', '{"id":"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX","name":"Super Big"}');
select tmp.doc_id
from (
  select t3.doc.id as doc_id
  from t3
  where t3.doc.name = "Super Big"
) as tmp;

create table t6 (
   a int not null,
   doc document not null) engine=innodb;
let $num=10000;
disable_query_log;
while($num)
{
  eval insert into t6 values($num,'{"id":1}');
  dec $num;
}
enable_query_log;
select count(*)
from (
  select t6.doc.id as id
  from t6
  where t6.a > 1000
  ) as tmp;

select t1_zipcode, t1_addr
from (
  select t1_addr.zipcode as t1_zipcode, t1_id, t1_addr
  from (
    select t1.doc.address as t1_addr, t1.doc.id as t1_id
    from t1 order by t1.doc.id desc
  ) as tmp1)
as tmp2;

select doc.address.state, addr.state from (
  select doc.address.state, doc.address as addr
  from t1
) as tmp1;

select count(doc.address.state) from (
  select doc.address
  from t1
) as tmp;

select count(*), test.t1.doc.address
from t1
group by test.t1.doc.address
having test.t1.doc.address.state = "NY";

select `count(*)`, id, addr.state
from (
  select count(*), test.t1.doc.id as id, test.t1.doc.address as addr
  from t1
  group by test.t1.doc.address
having test.t1.doc.address.state = "NY" or test.t1.doc.id = 106) as tmp;

drop table t6;

################################################################################
###
### Document paths with different types in UNION, UNION ALL, UNION DISTINCT 
###
###

--echo ##### Document paths with different types in UNION, UNION ALL, UNION DISTINCT 

CREATE TABLE t6 (
       a int not null,
       b char (10) not null,
       doc document not null) engine=innodb;
insert into t6 values (1,'@1','{ "id":101, "name":"Alex II", "phone":6507770001, "address":{ "houseNumber":1001, "streetName":"1st", "zipcode":98761, "state":"CA" } }');
insert into t6 values (2,'@2','{ "id":102, "name":"Bob II", "phone":6507770002, "address":{ "houseNumber":1002, "streetName":"2nd", "zipcode":98762, "state":"AZ" } }');
insert into t6 values (3,'@3','{ "id":103, "name":"Charlie II", "phone":6507770003, "address":{ "houseNumber":1003, "streetName":"3rd", "zipcode":98763, "state":"NY" } }');
insert into t6 values (4,'@4','{ "id":104, "name":"Don II", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" }, "Children":["Alex", "Bob", "Charlei"] }');


# Test union with doc columns and strings
(select doc from t1) UNION (select 'foo');
(select 'foo') UNION (select doc from t1);

(select doc from t1) UNION DISTINCT (select 'foo');
(select 'foo') UNION DISTINCT (select doc from t1);

(select doc from t1) UNION ALL (select 'foo');
(select 'foo') UNION ALL (select doc from t1);

# Test union with doc columns and strings with duplicates (expect dedup from UNION [DISTINCT])
(select doc from t1) UNION (select '{"id":106,"address":{"zipcode":98766}}');
(select '{"id":106,"address":{"zipcode":98766}}') UNION (select doc from t1);

(select doc from t1) UNION DISTINCT (select '{"id":106,"address":{"zipcode":98766}}');
(select '{"id":106,"address":{"zipcode":98766}}') UNION DISTINCT (select doc from t1);

(select doc from t1) UNION ALL (select '{"id":106,"address":{"zipcode":98766}}');
(select '{"id":106,"address":{"zipcode":98766}}') UNION ALL (select doc from t1);

# Test union with doc columns and DOCUMENT() values 
(select doc from t1) UNION (select DOCUMENT('{"foo": ["bar", 1, 0.1, []]}'));
(select DOCUMENT('{"foo": ["bar", 1, 0.1, []]}')) UNION (select doc from t1);

(select doc from t1) UNION DISTINCT (select DOCUMENT('{"foo": ["bar", 1, 0.1, []]}'));
(select DOCUMENT('{"foo": ["bar", 1, 0.1, []]}')) UNION DISTINCT (select doc from t1);

(select doc from t1) UNION ALL (select DOCUMENT('{"foo": ["bar", 1, 0.1, []]}'));
(select DOCUMENT('{"foo": ["bar", 1, 0.1, []]}')) UNION ALL (select doc from t1);

# Test union with doc columns and DOCUMENT() values with duplicates (expect dedup from UNION [DISTINCT])
(select doc from t1) UNION (select DOCUMENT('{"id":106,"address":{"zipcode":98766}}'));
(select DOCUMENT('{"id":106,"address":{"zipcode":98766}}')) UNION (select doc from t1);

(select doc from t1) UNION DISTINCT (select DOCUMENT('{"id":106,"address":{"zipcode":98766}}'));
(select DOCUMENT('{"id":106,"address":{"zipcode":98766}}')) UNION DISTINCT (select doc from t1);

(select doc from t1) UNION ALL (select DOCUMENT('{"id":106,"address":{"zipcode":98766}}'));
(select DOCUMENT('{"id":106,"address":{"zipcode":98766}}')) UNION ALL (select doc from t1);

# Test union with doc columns and integer (cast to string is needed)
(select doc from t1) UNION (select 42);
(select 42) UNION (select doc from t1);

(select doc from t1) UNION DISTINCT (select 42);
(select 42) UNION DISTINCT (select doc from t1);

(select doc from t1) UNION ALL (select 42);
(select 42) UNION ALL (select doc from t1);

# Test union with doc columns and double (cast to string is needed)
(select doc from t1) UNION (select 3.1415926);
(select 3.1415926) UNION (select doc from t1);

(select doc from t1) UNION DISTINCT (select 3.1415926);
(select 3.1415926) UNION DISTINCT (select doc from t1);

(select doc from t1) UNION ALL (select 3.1415926);
(select 3.1415926) UNION ALL (select doc from t1);

# Test union with doc columns and dates (cast to string is needed)
(select doc from t1) UNION (select DATE '2015-07-15');
(select DATE '2015-07-15') UNION (select doc from t1);

(select doc from t1) UNION DISTINCT (select DATE '2015-07-15');
(select DATE '2015-07-15') UNION DISTINCT (select doc from t1);

(select doc from t1) UNION ALL (select DATE '2015-07-15');
(select DATE '2015-07-15') UNION ALL (select doc from t1);

# Test union with doc columns and other table entries (check dedup)
(select doc2 from t2) UNION (select a from t5);
(select a2 from t2) UNION (select doc from t5);

# Test union with two document columns
(select doc from t5) UNION (select doc from t6);
(select doc from t5) UNION DISTINCT (select doc from t6);
(select doc from t5) UNION ALL (select doc from t6);

# Test union with order by inside the individual select clauses
(select doc2 from t2 ORDER BY doc2 LIMIT 3) UNION (select doc from t6 ORDER BY doc LIMIT 3);
(select doc2 from t2 ORDER BY doc2 LIMIT 3) UNION DISTINCT (select doc from t6 ORDER BY doc LIMIT 3);
(select doc2 from t2 ORDER BY doc2 LIMIT 3) UNION ALL (select doc from t6 ORDER BY doc LIMIT 3);

# Test union with order by after the union
(select doc2 from t2) UNION (select doc from t6) ORDER BY doc2 LIMIT 4;
(select doc2 from t2) UNION DISTINCT (select doc from t6) ORDER BY doc2 LIMIT 4 ;
(select doc2 from t2) UNION ALL (select doc from t6) ORDER BY doc2 LIMIT 4;

# Test union with order by after the union with aliases
(select doc2 as doc3 from t2) UNION (select doc from t6) ORDER BY doc3 LIMIT 4;
(select doc2 as doc3 from t2) UNION DISTINCT (select doc from t6) ORDER BY doc3 LIMIT 4 ;
(select doc2 as doc3 from t2) UNION ALL (select doc from t6) ORDER BY doc3 LIMIT 4;

# Test union between doc path and string (expect de-duplication)
# The order union'ed results are in order of left to right, and de-duplication always
# occurs on the later occurrence of elements so expect 'Alex' to be de-duped in different places.
(select doc.name from t1) UNION (select 'Alex');
(select 'Alex') UNION (select doc.name from t1);

(select doc.name from t1) UNION DISTINCT (select 'Alex');
(select 'Alex') UNION DISTINCT (select doc.name from t1);

(select doc.name from t1) UNION ALL (select 'Alex');
(select 'Alex') UNION ALL (select doc.name from t1);

# Test union with doc path and DOCUMENT() values with duplicates (expect dedup from UNION [DISTINCT])
# Expect '{"zipcode":98766}' to be de-duped at different places depending on order of UNION
(select doc.address from t1) UNION (select DOCUMENT('{"zipcode":98766}'));
(select DOCUMENT('{"zipcode":98766}')) UNION (select doc.address from t1);

(select doc.address from t1) UNION DISTINCT (select DOCUMENT('{"zipcode":98766}'));
(select DOCUMENT('{"zipcode":98766}')) UNION DISTINCT (select doc.address from t1);

(select doc.address from t1) UNION ALL (select DOCUMENT('{"zipcode":98766}'));
(select DOCUMENT('{"zipcode":98766}')) UNION ALL (select doc.address from t1);

# Test union with doc path and integer (expect dedup)
# Expect 101 to be de-duped at different places depending on order of UNION
(select doc.id from t1) UNION (select 101);
(select 101) UNION (select doc.id from t1);

(select doc.id from t1) UNION DISTINCT (select 101);
(select 101) UNION DISTINCT (select doc.id from t1);

(select doc.id from t1) UNION ALL (select 101);
(select 101) UNION ALL (select doc.id from t1);

# Test union with doc path and double (expect dedup)
# Expect 3.94065645841246 to be de-duped at different place depending on order of UNION
(select doc.double from t1) UNION (select 3.94065645841246);
(select 3.94065645841246) UNION (select doc.double from t1);

(select doc.double from t1) UNION DISTINCT (select 3.94065645841246);
(select 3.94065645841246) UNION DISTINCT (select doc.double from t1);

(select doc.double from t1) UNION ALL (select 3.94065645841246);
(select 3.94065645841246) UNION ALL (select doc.double from t1);

# Test union with doc paths and dates (expect dedup)
# Expect 2014-11-11 11:59:59 to be de-duped at different place depending on order of UNION
(select doc.dt from t1) UNION (select "2014-11-11 11:59:59");
(select "2014-11-11 11:59:59") UNION (select doc.dt from t1);

(select doc.dt from t1) UNION DISTINCT (select "2014-11-11 11:59:59");
(select "2014-11-11 11:59:59") UNION DISTINCT (select doc.dt from t1);

(select doc.dt from t1) UNION ALL (select "2014-11-11 11:59:59");
(select "2014-11-11 11:59:59") UNION ALL (select doc.dt from t1);

# Test union between doc paths
(select doc.address from t1) UNION (select doc.address from t1);
(select doc.address from t1) UNION DISTINCT (select doc.address from t1);
(select doc.address from t1) UNION ALL (select doc.address from t1);

# Test simple union with doc in sub query but no doc path extension in outer query
select doc.address from (
  (select doc.address from t1)
  UNION
  (select doc.address from t1)
) as tmp;

# Use UNION as the inner query and include an extended doc path in the outer query
select doc.address.state from (
  (select doc.address from t1)
  UNION
  (select doc.address from t1)
) as tmp;

# Use UNION as the inner query with DOCUMENT() literal and include an extended doc path in the outer query
select doc.address.zipcode from (
  (select doc.address from t1)
  UNION
  (select DOCUMENT('{"zipcode":98767,"state":"NY"}'))
) as tmp;
select alias.zipcode from (
  (select DOCUMENT('{"zipcode":98767,"state":"NY"}') as alias)
  UNION ALL
  (select doc.address from t1)
) as tmp;

# This should error because the name of the UNION column is that of the first column (so doc path name in second query is ignored)
--error ER_BAD_FIELD_ERROR
select doc.address.zipcode from (
  (select DOCUMENT('{"zipcode":98767,"state":"NY"}'))
  UNION
  (select doc.address from t1)
) as temp;

# This should error as the inner query type is not DOCUMENT so you can't extend doc path in the outer query
--error ER_BAD_FIELD_ERROR
select doc.address.zipcode from (
  (select doc.address from t1)
  UNION
  (select '{"zipcode":98767, "state":"NY"}')
) as tmp;

# Test UNION in two table with document path
(select doc.address from t1) UNION (select doc2.address from t2);
(select doc2.address from t2) UNION ALL (select doc.address from t1);
(select doc.address from t1) UNION DISTINCT (select doc2.address from t2);

# Test doc paths in UNION from different tables as sub query
select doc.address.state from (
  (select doc.address from t1)
  UNION
  (select doc2.address from t2)
) as tmp;
select doc.address.state from (
  (select doc.address from t1)
  UNION ALL
  (select doc2.address from t2)
) as tmp;

# Test doc paths in UNION from different tables as sub query using alias
select addr.state from (
  (select doc.address as addr from t1)
  UNION
  (select doc2.address from t2)
) as tmp;
select addr.state from (
  (select doc.address as addr from t1)
  UNION ALL
  (select doc2.address from t2)
) as tmp;

################################################################################
###
### Clean up
###

--echo ##### Clean up

# Restore the original value
SET @@global.allow_document_type = @start_allow_document_type;
SELECT @@global.allow_document_type;

drop table t1, t2, t3, t4, t5, t6;

--source include/rpl_end.inc

--source include/master-slave.inc
connection master;

################################################################################
###
### Test of document path of document type
###

--disable_warnings
drop table if exists t1, t2, t3, t4, t5;
--enable_warnings

SET @start_allow_document_type = @@global.allow_document_type;
SELECT @start_allow_document_type;

################################################################################
###
### t1 and t2 : populate data
###

--echo ##### Create tables t1 and t2 and populate data

CREATE TABLE t1 (
       a int not null,
       b char (10) not null,
       doc document not null) engine=innodb;

insert into t1 values (1,'@1','{ "id":101, "name":"Alex", "phone":6507770001, "address":{ "houseNumber":1001, "streetName":"1st", "zipcode":98761, "state":"CA" }, "intstr":"1001", "dt":"1001" }');
insert into t1 values (2,'@2','{ "id":102, "name":"Bob", "phone":6507770002, "address":{ "houseNumber":1002, "streetName":"2nd", "zipcode":98762, "state":"AZ" }, "int64":2222222220123456789, "intstr":"1002", "dt":"0123456789ABCDEFGHIGKLMNOPQRSTUVWXYZ0123456789" }');
insert into t1 values (3,'@3','{ "id":103, "name":"Charlie", "phone":6507770003, "address":{ "houseNumber":1003, "streetName":"3rd", "zipcode":98763, "state":"NY" }, "double":3.94065645841246, "dt":"2014-11-01" }');
insert into t1 values (4,'@1','{ "id":104, "name":"Don", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" }, "Children":["Alex", "Bob", "Charlei"] }');
insert into t1 values (5,'@2','{ "id":105, "name":"Evan", "phone":6507770005, "address":{ "houseNumber":1005, "streetName":"5th", "zipcode":98765, "state":"WA" }, "dt":"2014-11-11 11:59:59" }');
insert into t1 values (8,'@1','{ "id":108, "address":{ "zipcode":98768 } }');
insert into t1 values (7,'@3','{ "id":107, "address":{ "zipcode":98767, "state":"NY" } }');
insert into t1 values (6,'@2','{ "id":106, "address":{ "zipcode":98766 } }');
insert into t1 values (9,'@1','{ "id":109, "name":"Linda", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" } }');


CREATE TABLE t2 (
       a2 int not null,
       b2 char (10) not null,
       doc2 document not null) engine=innodb;

insert into t2 values (10,'@3','{ "id":105, "name":"Alex II", "phone":6507770001, "address":{ "houseNumber":1001, "streetName":"1st", "zipcode":98761, "state":"CA" } }');
insert into t2 values (8,'@1','{ "id":108, "name":"Bob II", "phone":6507770002, "address":{ "houseNumber":1002, "streetName":"2nd", "zipcode":98762, "state":"AZ" } }');
insert into t2 values (3,'@3','{ "id":104, "name":"Charlie II", "phone":6507770003, "address":{ "houseNumber":1003, "streetName":"3rd", "zipcode":98763, "state":"NY" } }');
insert into t2 values (5,'@2','{ "id":106, "name":"Don II", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" }, "Children":["Alex", "Bob", "Charlei"] }');

################################################################################
###
### t3 : big values
###
### The max size is 1100 characters, which is greater than the default sort field length 1024
### so it will be truncated when it is the sorting key in order by clause
###

--echo ##### Create tables t3 with big values

CREATE TABLE t3 (
       a int not null,
       b char (10) not null,
       doc document not null) engine=innodb;

insert into t3 values (3,'@3','{ "id":"3333", "name":"Charlie" }');
insert into t3 values (1,'@1','{ "id":"1", "name":"Alex" }');
insert into t3 values (4,'@4','{ "id":"44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444", "name":"Don" }');

insert into t3 values (2,'@2','{ "id":"22", "name":"Bob" }');

################################################################################
###
### t4 : backtick quoted column name with special characters
###
### TODO: \t
###

--echo ##### Create tables t4 with backtick quoted column name with special characters

CREATE TABLE t4 (
       `~!@#$%^&*()_+-=:;'"<>?,./\t` document not null) engine=innodb;

### \" is not allowed in json key
insert into t4 values ('{"k1":"v1"}');
insert into t4 values ('{"~!@#$%^&*()_+-=:;\'<>?,./":{"~!@#$%^&*()_+-=:;\'<>?,./":"v2"}}');
insert into t4 values ('{"k3":"v3"}');
insert into t4 values ('{"k4":"v4"}');

CREATE TABLE t5 (
       a int not null,
       b char (10) not null,
       doc document not null,
       doc2 document not null) engine=innodb;
insert into t5 values (1,'@1','{ "id":101, "name":"Alex II", "phone":6507770001, "address":{ "houseNumber":1001, "streetName":"1st", "zipcode":98761, "state":"CA" } }','{ "id":204, "name":"Alex II", "phone":6507770001, "address":{ "houseNumber":1001, "streetName":"1st", "zipcode":98761, "state":"CA" } }');
insert into t5 values (2,'@2','{ "id":102, "name":"Bob II", "phone":6507770002, "address":{ "houseNumber":1002, "streetName":"2nd", "zipcode":98762, "state":"AZ" } }','{ "id":203, "name":"Bob II", "phone":6507770002, "address":{ "houseNumber":1002, "streetName":"2nd", "zipcode":98762, "state":"AZ" } }');
insert into t5 values (3,'@3','{ "id":103, "name":"Charlie II", "phone":6507770003, "address":{ "houseNumber":1003, "streetName":"3rd", "zipcode":98763, "state":"NY" } }','{ "id":202, "name":"Charlie II", "phone":6507770003, "address":{ "houseNumber":1003, "streetName":"3rd", "zipcode":98763, "state":"NY" } }');
insert into t5 values (4,'@4','{ "id":104, "name":"Don II", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" }, "Children":["Alex", "Bob", "Charlei"] }','{ "id":201, "name":"Don II", "phone":6507770004, "address":{ "houseNumber":1004, "streetName":"4th", "zipcode":98764, "state":"WA" }, "Children":["Alex", "Bob", "Charlei"] }');

select `~!@#$%^&*()_+-=:;'"<>?,./\t`
from t4;

select `~!@#$%^&*()_+-=:;'"<>?,./\t`.`~!@#$%^&*()_+-=:;'<>?,./`.`~!@#$%^&*()_+-=:;'<>?,./`
from t4
where `~!@#$%^&*()_+-=:;'"<>?,./\t`.`~!@#$%^&*()_+-=:;'<>?,./`.`~!@#$%^&*()_+-=:;'<>?,./` like "v2";


################################################################################
###
### The original cases: database.table.field, table.field and .table.field
###

--echo ##### When document type is disabled, the original cases of database.table.field, table.field and .table.field

### Disable document type to make parser work as before
SET @@global.allow_document_type = false;
SELECT @@global.allow_document_type;

### The original cases 1: database.table.field
select test.t1.b from test.t1 where test.t1.a = 1;

### The original cases 2: table.field
select t1.doc from test.t1 where t1.a = 2;

### The original cases 3: .table.field
select .t1.doc from test.t1 where .t1.a = 4;


################################################################################
###
### When document type is disabled, all the new syntax will be treated as errors
###

--echo ##### When document type is disabled, all the new syntax will be treated as errors

--error ER_INVALID_FIELD_OR_REFERENCE
select test.t1.doc.address.houseNumber from t1 where t1.a = 3;

--error ER_INVALID_FIELD_OR_REFERENCE
select a from t1 where test.t1.doc.id = 102;

--error ER_INVALID_FIELD_OR_REFERENCE
select test.t1.doc.address.houseNumber from t1 where test.t1.doc.address.zipcode = 98762;

### Enable document type with the new parsing logic
SET @@global.allow_document_type = true;
SELECT @@global.allow_document_type;

### All the three original cases work as before
select test.t1.b from test.t1 where test.t1.a = 1;
select t1.doc from test.t1 where t1.a = 2;
select .t1.doc from test.t1 where .t1.a = 4;


################################################################################
###
### Invalid document path: using document path on a non-document column
###

--echo ##### Invalid document path when using document path on a non-document column

### Disable document type to make parser work as before
SET @@global.allow_document_type = false;
SELECT @@global.allow_document_type;

--error ER_BAD_FIELD_ERROR
select b.k1 from t1;
--error ER_BAD_FIELD_ERROR
select b.k1.k2 from t1;
--error ER_INVALID_FIELD_OR_REFERENCE
select b.k1.k2.k3 from t1;

### Enable document type with the new parsing logic
SET @@global.allow_document_type = true;
SELECT @@global.allow_document_type;

## In SELECT
--error ER_BAD_FIELD_ERROR
select b.k1 from t1;
--error ER_BAD_FIELD_ERROR
select b.k1.k2 from t1;
--error ER_BAD_FIELD_ERROR
select b.k1.k2.k3 from t1;

## In WHERE
--error ER_BAD_FIELD_ERROR
select a from t1 where b.k1 = 100;
--error ER_BAD_FIELD_ERROR
select a from t1 where b.k1.k2 = 100;
--error ER_BAD_FIELD_ERROR
select a from t1 where b.k1.k2.k3 = 100;

## In ORDER BY
--error ER_BAD_FIELD_ERROR
select a from t1 order by b.k1;
--error ER_BAD_FIELD_ERROR
select a from t1 order by b.k1.k2 ;
--error ER_BAD_FIELD_ERROR
select a from t1 order by b.k1.k2.k3;

## In GROUP BY
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by b.k1;
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by b.k1.k2;
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by b.k1.k2.k3;

## In HAVING
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by a having b.k1 = 100;
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by a having b.k1.k2 = 100;
--error ER_BAD_FIELD_ERROR
select count(*), a from t1 group by a having b.k1.k2.k3 = 100;

## In HAVING without GROUP BY then HAVING clause behaves like WHERE clause
--error ER_BAD_FIELD_ERROR
select a from t1 having b.k1 = 100;
--error ER_BAD_FIELD_ERROR
select a from t1 having b.k1.k2 = 100;
--error ER_BAD_FIELD_ERROR
select a from t1 having b.k1.k2.k3 = 100;

## In Functions
--error ER_BAD_FIELD_ERROR
select a from t1 where substr(b.k1, 1, 10) like 'abc';
--error ER_BAD_FIELD_ERROR
select a from t1 where substr(b.k1.k2, 1, 10) like 'abc';
--error ER_BAD_FIELD_ERROR
select a from t1 where substr(b.k1.k2.k3, 1, 10) like 'abc';

--error ER_BAD_FIELD_ERROR
select sum(b.k1) from t1 where a = 100;
--error ER_BAD_FIELD_ERROR
select sum(b.k1.k2) from t1 where a = 100;
--error ER_BAD_FIELD_ERROR
select sum(b.k1.k2.k3) from t1 where a = 100;


################################################################################
###
### Document partial update by document path is not supported yet
###

--echo ##### Document partial update by document path is not supported yet

### When document type is disabled
SET @@global.allow_document_type = false;
SELECT @@global.allow_document_type;

--error ER_BAD_FIELD_ERROR
update t1 set t1.doc.id = 200 where a = 1;

### When document type is enabled
SET @@global.allow_document_type = true;
SELECT @@global.allow_document_type;

--error ER_DOCUMENT_PARTIAL_UPDATE_NOT_SUPPORTED_YET
update t1 set t1.doc.id = 200 where a = 1;

--error ER_DOCUMENT_PARTIAL_UPDATE_NOT_SUPPORTED_YET
update t1 set t1.doc.name = "Raymond" where a = 1;

--error ER_DOCUMENT_PARTIAL_UPDATE_NOT_SUPPORTED_YET
insert into t1 set a = 10, b = '@9', t1.doc.id = 200;

--disable_warnings ONCE
drop procedure if exists sp1;
create procedure sp1()
  update t1 set t1.doc.id = 200 where a = 1;
--error ER_DOCUMENT_PARTIAL_UPDATE_NOT_SUPPORTED_YET
call sp1();
drop procedure sp1;

--disable_warnings ONCE
drop procedure if exists sp2;
create procedure sp2()
  insert into t1 set a = 10, b = '@9', t1.doc.id = 200;
--error ER_DOCUMENT_PARTIAL_UPDATE_NOT_SUPPORTED_YET
call sp2();
drop procedure sp2;


################################################################################
###
### Document path with different types in SELECT clause (with and without aliases)
###

--echo ##### Document path with different types in SELECT clause

### Document path in SELECT clause: database.table.field.key1, in which key1 does not exist
### Expecting empty string
select test.t1.doc.NonExistent from t1 where t1.a = 4;
select test.t1.doc.NonExistent as NonExistent from t1 where t1.a = 4;

### Regular document field in SELECT clause: database.table.field
select test.t1.doc from t1 where t1.a = 3;
select test.t1.doc as doc from t1 where t1.a = 3;

### Document path in SELECT clause: database.table.field.key1.key2 that points to an int16
select test.t1.doc.address.houseNumber from t1 where t1.a = 3;
select test.t1.doc.address.houseNumber as houseNumber from t1 where t1.a = 3;

### Document paths in SELECT clause: database.table.field.key1 that points to an int64
select test.t1.doc.int64 from t1 where t1.a = 2;
select test.t1.doc.int64 as int64 from t1 where t1.a = 2;

### Document paths in SELECT clause: database.table.field.key1 that points to an double
select test.t1.doc.double from t1 where t1.a = 3;
select test.t1.doc.double as dble from t1 where t1.a = 3;

### Document paths in SELECT clause: database.table.field.key1 that points to an string
select test.t1.doc.name from t1 where t1.a = 3;
select test.t1.doc.name as name from t1 where t1.a = 3;

### Document paths in SELECT clause: database.table.field.key1.array_index that points to an string
### FBSon array index is 0-based
select test.t1.doc.Children.0 from t1 where t1.a = 4;
select test.t1.doc.Children.1 from t1 where t1.a = 4;
select test.t1.doc.Children.2 from t1 where t1.a = 4;
select test.t1.doc.Children.0 as Children0 from t1 where t1.a = 4;

### Document paths in function in SELECT clause
select abs(test.t1.doc.double), abs(test.t1.doc.double - 3.94065645841245) from t1 where a = 3;
select abs(test.t1.doc.double) as abs1, abs(test.t1.doc.double - 3.94065645841245) as abs2
from t1
where a = 3;

### Document paths in SELECT clause: database.table.field.key1 that points to an JSON object
select test.t1.doc.address from t1 where t1.a = 3;
select test.t1.doc.address as address from t1 where t1.a = 3;

### Document paths in SELECT clause: database.table.field.key1 that points to an JSON array
select test.t1.doc.Children from t1 where t1.a = 4;
select test.t1.doc.Children as Children from t1 where t1.a = 4;

### Document paths in SELECT clause: table.field.key1 that needs right shift for one during fixing
select t1.doc.address.houseNumber from t1 where t1.a = 4;
select t1.doc.address.houseNumber as houseNumber from t1 where t1.a = 4;

### Document paths in SELECT clause: field.key1.key2 that needs right shift for two during fixing
select doc.address.houseNumber from t1 where t1.a = 4;
select doc.address.houseNumber as houseNumber from t1 where t1.a = 4;


################################################################################
###
### Document paths with different types in WHERE clause
###

--echo ##### Document paths with different types in WHERE clause

### Document paths in WHERE clause: database.table.field.key1, in which key1 does not exist
### Expecting empty result
select a from t1 where test.t1.doc.NonExistent = 102;

### Document paths in WHERE clause: database.table.field.key1 = int,
### the document paths value will be retrived as real
select a from t1 where test.t1.doc.id = 102;

### int64
select a from t1 where test.t1.doc.int64 = 2222222220123456789;

### Use document paths in function in WHERE clause
### Use threshold to deal with the precision issue when comparing two doubles
select a from t1 where abs(test.t1.doc.double - 3.94065645841246) < 0.0000001;

### Same document paths appears in both SELECT and WHERE clause
select t1.doc.id from t1 where t1.doc.id > 101 and t1.doc.id < 104;

### string
select a from t1 where test.t1.doc.name like "Bob";

select a from t1 where substring(test.t1.doc.name, 1, 2) like "Bo";

### cast as unsigned
select a from t1 where cast(test.t1.doc.id as unsigned) = 102;

select a from t1 where cast(test.t1.doc.intstr as unsigned) = 1002;

### cast as char
select a from t1 where cast(test.t1.doc.id as char) like "102";

### cast as date
select test.t1.doc.dt from t1 where cast(test.t1.doc.dt as date) = cast('2014-11-01' as date);

### cast as datetime
select test.t1.doc.dt from t1 where cast(test.t1.doc.dt as datetime) = cast('2014-11-11 11:59:59' as datetime);

### cast as timestamp
select test.t1.doc.dt from t1 where cast(test.t1.doc.dt as time) = cast('2014-11-11 11:59:59' as time);

### Document path in both SELECT and WHERE clause: database.table.field.key1.key2
select test.t1.doc.address.houseNumber from t1 where test.t1.doc.address.zipcode = 98762;

### Document paths in WHERE clause for UPDATE statements
select t1.a, t1.b from t1 where doc.address.zipcode = 98761;
update t1 set t1.a = 101, t1.b = '@101' where doc.address.zipcode = 98761;
select t1.a, t1.b from t1 where doc.address.zipcode = 98761;
update t1 set t1.a = 1, t1.b = '@1' where doc.address.zipcode = 98761;
select t1.a, t1.b from t1 where doc.address.zipcode = 98761;


################################################################################
###
### Document paths with different types in ORDER BY clause (with aliases and positions)
###

--echo ##### Document paths with different types in ORDER BY clause (with and without aliases)

### Document paths in ORDER BY clause: database.table.field.key1, in which key1 does not exist
### the results won't be sorted
select a from t1 order by test.t1.doc.NonExistent, a;
select a from t1 order by cast(t1.doc.NonExistent as unsigned), a;

### use cast to make it sorted as unsigned
select test.t1.doc.id, a from t1 order by cast(test.t1.doc.id as unsigned);
select test.t1.doc.id, a from t1 order by cast(test.t1.doc.id as unsigned) desc;
select test.t1.doc.id, a from t1 order by 1 desc;

select test.t1.doc.address.zipcode, a from t1 order by cast(test.t1.doc.address.zipcode as signed), 2;
select test.t1.doc.address.zipcode, a from t1 order by cast(test.t1.doc.address.zipcode as char) desc, 2;

### use alias for the whole cast function
select cast(test.t1.doc.address.zipcode as signed), a
from t1
order by cast(test.t1.doc.address.zipcode as signed), a;

select cast(test.t1.doc.address.zipcode as signed) as zipcode, a
from t1
order by zipcode, a;

select cast(test.t1.doc.address.zipcode as char), a
from t1
order by cast(test.t1.doc.address.zipcode as char) desc, a;

select cast(test.t1.doc.address.zipcode as char), a
from t1
order by 1 desc, a;

select cast(test.t1.doc.address.zipcode as char) as zipcode, a
from t1
order by zipcode desc, a;

select a, cast(test.t1.doc.address.zipcode as char) as zipcode
from t1
order by 2 desc, a;

### use alias of document path within cast function
select a, test.t1.doc.address.state as state
from t1
order by cast(state as char), a;

select a, test.t1.doc.address.state as state
from t1
order by cast(state as char) desc, a;

select a, test.t1.doc.address.zipcode as zipcode
from t1
order by cast(zipcode as char), a;

select a, test.t1.doc.address.zipcode as zipcode
from t1
order by cast(zipcode as char) desc, a;

select a, test.t1.doc.address.zipcode as zipcode
from t1
order by cast(zipcode as unsigned), a;

select a, test.t1.doc.address.zipcode as zipcode
from t1
order by cast(zipcode as unsigned) desc, a;

### without cast to make it sorted as string
select test.t1.doc.id, a from t1 order by test.t1.doc.id, a;
select test.t1.doc.id, a from t1 order by t1.doc.id desc, a;

select test.t1.doc.id as id, a from t1 order by id, a;
select test.t1.doc.id as id, a from t1 order by id desc, a;

### big string with length of 1110 won't be truncated
select doc.id, a from t3 order by test.t3.doc.id, a;
select test.t3.doc.id, a from t3 order by t3.doc.id desc, a;
select test.t3.doc.id, a from t3 where a = 4;

### without NULL values

### document path is the only SELECT time
select test.t1.doc.address.zipcode from t1 order by test.t1.doc.address.zipcode;
select test.t1.doc.address.zipcode from t1 order by t1.doc.address.zipcode desc;

select test.t1.doc.address.zipcode as zipcode from t1 order by zipcode;
select test.t1.doc.address.zipcode as zipcode from t1 order by zipcode desc;

### document path is the last SELECT time
select a, test.t1.doc.address.zipcode from t1 order by test.t1.doc.address.zipcode, a;
select a, test.t1.doc.address.zipcode from t1 order by t1.doc.address.zipcode desc, a;

select a, test.t1.doc.address.zipcode as zipcode from t1 order by zipcode, a;
select a, test.t1.doc.address.zipcode as zipcode from t1 order by zipcode desc, a;

### document path is not the last SELECT time
select test.t1.doc.address.zipcode, a from t1 order by test.t1.doc.address.zipcode, a;
select test.t1.doc.address.zipcode, a from t1 order by t1.doc.address.zipcode desc, a;

select test.t1.doc.address.zipcode as zipcode, a from t1 order by zipcode, a;
select test.t1.doc.address.zipcode as zipcode, a from t1 order by zipcode desc, a;

### with NULL values

### document path is the only SELECT time
select test.t1.doc.address.state from t1 order by test.t1.doc.address.state;
select test.t1.doc.address.state from t1 order by t1.doc.address.state desc;
select test.t1.doc.address.state from t1 order by 1 desc;

select test.t1.doc.address.state as state from t1 order by state;
select test.t1.doc.address.state as state from t1 order by state desc;

### document path is the last SELECT time
select a, test.t1.doc.address.state from t1 order by test.t1.doc.address.state, a;
select a, test.t1.doc.address.state from t1 order by t1.doc.address.state desc, a;

select a, test.t1.doc.address.state as state from t1 order by state, a;
select a, test.t1.doc.address.state as state from t1 order by state desc, a;

### document path is not the last SELECT time
select test.t1.doc.address.state, a from t1 order by test.t1.doc.address.state, a;
select test.t1.doc.address.state, a from t1 order by t1.doc.address.state desc, a;

select test.t1.doc.address.state as state, a from t1 order by state, a;
select test.t1.doc.address.state as state, a from t1 order by state desc, a;

### multiple non-duplicate document paths
select doc.address.state as state, doc.address.zipcode as zipcode, a
from t1
order by state, zipcode, a;

select doc.address.state as state, doc.address.zipcode as zipcode, a
from t1
order by zipcode desc, state desc, a asc;

select doc.address.state as state, doc.address.zipcode as zipcode, doc.name as name, a
from t1
order by zipcode desc, state desc, name desc, a asc;

select a, doc.address.state as state, doc.address.zipcode as zipcode
from t1
order by a desc, state asc, zipcode desc;

select a, doc.address.state, doc.address.zipcode
from t1
order by test.t1.doc.address.zipcode desc, t1.doc.address.state asc, a desc;

select a, doc.address.state, doc.address.zipcode, doc.name
from t1
order by test.t1.doc.address.zipcode desc, t1.doc.address.state asc, doc.name desc, a desc;

select a, doc.address.state, doc.address.zipcode
from t1
order by doc.address.zipcode, doc.address.state, a;

select a, doc.address.state, doc.address.zipcode
from t1
order by doc.address.zipcode, doc.address.state, doc.name, a;

### document field and document paths in ORDER BY without document path in SELECT
select a
from t1
order by doc;

select a
from t1
order by doc desc;

select a
from t1
order by doc, doc.address.state desc, doc.address.zipcode;

### multiple duplicate document paths
select doc.address.state as state, doc.address.zipcode as zipcode, a
from t1
order by state, state, a;

select doc.address.zipcode as zipcode, a
from t1
order by test.t1.doc.address.zipcode, t1.doc.address.zipcode, a asc;

select doc.address.state as state, a
from t1
order by state, test.t1.doc.address.state, a desc;

### test selecting and ordering by different doc paths
select doc.address.zipcode
from t1
order by doc.address.state, a;

select t1.doc.address.zipcode
from t1
order by doc.address.state, a;

select doc.address.state
from t1
order by doc.address.zipcode, a;

select t1.doc.address.state
from t1
order by doc.address.zipcode, a;

### test single doc path in select and order by doc column (and vice-versa)
select doc.address.state
from t1
order by doc;

select doc
from t1
order by doc.address.state, a;

select t1.doc.address.state
from t1
order by doc;

select t1.doc
from t1
order by doc.address.state, a;

### test selecting both doc path and doc column being after single order by
select doc, doc.address.state
from t1
order by doc;

select doc.address.state, doc
from t1
order by doc;

select doc, doc.address.state
from t1
order by doc.address.state, a;

select doc.address.state, doc
from t1
order by doc.address.state, a;

select t1.doc, t1.doc.address.state
from t1
order by doc;

select t1.doc.address.state, t1.doc
from t1
order by doc;

select t1.doc, t1.doc.address.state
from t1
order by doc.address.state, a;

select t1.doc.address.state, t1.doc
from t1
order by doc.address.state, a;

### test selecting one field but order by doc column and doc path
select doc.address.state
from t1
order by doc, doc.address.state;

select doc.address.state
from t1
order by doc.address.state, doc;

select doc
from t1
order by doc, doc.address.state;

select doc
from t1
order by doc.address.state, doc;

select t1.doc.address.state
from t1
order by doc, doc.address.state;

select t1.doc.address.state
from t1
order by doc.address.state, doc;

select t1.doc
from t1
order by doc, doc.address.state;

select t1.doc
from t1
order by doc.address.state, doc;

### test selecting doc path, doc column and order by same doc path, doc column
select doc, doc.address.state
from t1
order by doc, doc.address.state;

select doc.address.state, doc
from t1
order by doc, doc.address.state;

select doc, doc.address.state
from t1
order by doc.address.state, doc;

select doc.address.state, doc
from t1
order by doc.address.state, doc;

select t1.doc, t1.doc.address.state
from t1
order by doc, doc.address.state;

select t1.doc.address.state, t1.doc
from t1
order by doc, doc.address.state;

select t1.doc, t1.doc.address.state
from t1
order by doc.address.state, doc;

select t1.doc.address.state, t1.doc
from t1
order by doc.address.state, doc;

### test selecting a doc path/doc columns and ordering by doc columns and aliases
select doc.address.state as state
from t1
order by doc;

select doc.address.state as state
from t1
order by state, a;

select doc.address.state as state
from t1
order by doc.address.state, a;

select doc as doc2 
from t1
order by doc.address.state, a;

select doc as doc2 
from t1
order by doc2;

select doc as doc2 
from t1
order by doc;

select t1.doc.address.state as state
from t1
order by doc;

select t1.doc.address.state as state
from t1
order by state, a;

select t1.doc.address.state as state
from t1
order by doc.address.state, a;

select t1.doc as doc2 
from t1
order by doc.address.state, a;

select t1.doc as doc2 
from t1
order by doc2;

select t1.doc as doc2 
from t1
order by doc;

### test selecting/ordering different doc paths from different columns of same table
select doc.id
from t5
order by doc2.id;

select t5.doc.id
from t5
order by doc2.id;

select doc2.id
from t5
order by doc.id;

select t5.doc2.id
from t5
order by doc.id;

select doc.id
from t5
order by doc.id;

select doc2.id
from t5
order by doc2.id;

select t5.doc.id
from t5
order by doc.id;

select t5.doc2.id
from t5
order by doc2.id;

################################################################################
###
### Document paths with different types in GROUP BY without HAVING clause (with aliases and positions)
###

--echo ##### Document paths with different types in GROUP BY without HAVING clause (with and without aliases)

### cast to string
select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char);

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by 2;

select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by state;

select cast(test.t1.doc.address.state as char) as state, count(*)
from t1
group by 1;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char) desc;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by 2 desc;

### Alias of the whole cast function
select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by state desc;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char)
order by cast(test.t1.doc.address.state as char) desc;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by 2
order by 2 desc;

select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by state
order by state desc;

select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by 2
order by 2 desc;

select count(*), cast(test.t1.doc.address.state as char)
from t1
group by cast(test.t1.doc.address.state as char)
order by cast(test.t1.doc.address.state as char) desc;

select count(*), cast(test.t1.doc.address.state as char) as state
from t1
group by state
order by state desc;

# use alias of document path within cast function
select count(*), test.t1.doc.address.state as state
from t1
group by cast(state as char);

select count(*), test.t1.doc.address.state as state
from t1
group by cast(state as char) desc;

select count(*), test.t1.doc.address.state as state
from t1
group by cast(state as char)
order by cast(state as char);

select count(*), test.t1.doc.address.state as state
from t1
group by cast(state as char)
order by cast(state as char) desc;

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by cast(zipcode as char);

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by cast(zipcode as char) desc;

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by cast(zipcode as unsigned)
order by cast(zipcode as unsigned);

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by cast(zipcode as unsigned)
order by cast(zipcode as unsigned) desc;

### use document paths directly with default string type
select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.state;

select count(*), test.t1.doc.address.state as state
from t1
group by state;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.state desc;

select count(*), test.t1.doc.address.state as state
from t1
group by state desc;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.state
order by test.t1.doc.address.state desc;

select count(*), test.t1.doc.address.state
from t1
group by 2
order by 2 desc;

select test.t1.doc.address.state, count(*)
from t1
group by 1
order by 1 desc;

select count(*), test.t1.doc.address.state as state
from t1
group by state
order by state desc;

### cast to string
select count(*) as total, test.t1.doc.address.state
from t1
group by cast(test.t1.doc.address.state as char)
having total > 1;

select count(*) as total, test.t1.doc.address.state
from t1
group by cast(test.t1.doc.address.state as char) desc
having total >= 2;

select count(*) as total, test.t1.doc.address.state
from t1
group by cast(test.t1.doc.address.state as char)
having total > 1
order by cast(test.t1.doc.address.state as char) desc;

### use document paths directly with default string type
select count(*) as total, test.t1.doc.address.state
from t1
group by test.t1.doc.address.state
having total >= 2;

select count(*) as total, test.t1.doc.address.state
from t1
group by 2
having total >= 2;

select count(*) as total, test.t1.doc.address.state as state
from t1
group by state
having total >= 2;

select count(*) as total, test.t1.doc.address.state
from t1
group by test.t1.doc.address.state desc
having total > 1;

select test.t1.doc.address.state, count(*) as total
from t1
group by 1 desc
having total > 1;

select count(*) as total, test.t1.doc.address.state as state
from t1
group by state desc
having total > 1;

select count(*) as total, test.t1.doc.address.state
from t1
group by test.t1.doc.address.state
having total >= 2
order by test.t1.doc.address.state desc;

select count(*) as total, test.t1.doc.address.state
from t1
group by 2
having total >= 2
order by 2 desc;

select count(*) as total, test.t1.doc.address.state as state
from t1
group by state
having total >= 2
order by state desc;

select test.t1.doc.address.state as state, count(*) as total
from t1
group by 1
having total >= 2
order by 1 desc;

### Sorted as string and big values will be truncated with warnings
select doc.id, a from t3 group by doc.id;
show warnings;


################################################################################
###
### Document paths with different types in GROUP BY with HAVING clause (with aliases and positions)
###
###

--echo ##### Document paths with different types in GROUP BY with HAVING clause (with and without aliases)

# The fields or document paths in HAVING must be in GROUP BY but don't have to be in SELECT
select count(*), test.t1.doc.address.state
from t1
group by t1.doc.address.zipcode
having doc.address.zipcode = 98761;

### the returned type will be string
select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.state
having test.t1.doc.address.state like "NY";

select count(*), test.t1.doc.address.state
from t1
group by 2
having test.t1.doc.address.state like "NY";

select count(*), doc.address.state
from t1
group by doc.address.state
having test.t1.doc.address.state like "NY";

select count(*), doc.address.state
from t1
group by doc.address.state
having doc.address.state like "NY";

select count(*), t1.doc.address.state
from t1
group by doc.address.state
having test.t1.doc.address.state like "NY";

select count(*), doc.address.state
from t1
group by t1.doc.address.state
having test.t1.doc.address.state like "NY";

select count(*), doc.address.state
from t1
group by t1.doc.address.state
having doc.address.state like "NY";

select count(*), test.t1.doc.address.state as state
from t1
group by state
having state like "NY";

### the returned type will be number
select count(*), test.t1.doc.address.zipcode
from t1
group by test.t1.doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select test.t1.doc.address.zipcode, count(*)
from t1
group by 1
having test.t1.doc.address.zipcode = 98761;

select test.t1.doc.address.zipcode, count(*)
from t1
group by 1
having doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.zipcode as zipcode
from t1
group by zipcode
having zipcode = 98761;

select count(*), doc.address.zipcode
from t1
group by doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), t1.doc.address.state
from t1
group by doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having test.t1.doc.address.zipcode = 98768;

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having t1.doc.address.zipcode = 98768;

### two document pathes with aliases
select count(*), test.t1.doc.address.state, test.t1.doc.address.zipcode
from t1
group by test.t1.doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state, test.t1.doc.address.zipcode
from t1
group by 3
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state, test.t1.doc.address.zipcode
from t1
group by 3
having doc.address.zipcode = 98761;

select count(*), doc.address.state, doc.address.zipcode
from t1
group by doc.address.zipcode
having test.t1.doc.address.zipcode = 98761;

select count(*), test.t1.doc.address.state as state, test.t1.doc.address.zipcode as zipcode
from t1
group by state
having state like "NY";

select count(*), test.t1.doc.address.state as state, test.t1.doc.address.zipcode as zipcode
from t1
group by zipcode
having zipcode = 98761;

select count(*), test.t1.doc.address.state as state, test.t1.doc.address.zipcode as zipcode
from t1
group by 3
having zipcode = 98761;

### cast from number to string
select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having cast(test.t1.doc.address.zipcode as char) like '98761';

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having cast(test.t1.doc.address.zipcode as char) like '98768';

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having cast(t1.doc.address.zipcode as char) like '98761';

select count(*), test.t1.doc.address.state
from t1
group by test.t1.doc.address.zipcode
having cast(doc.address.zipcode as char) like '98761';

### Big value in HAVING will be truncated to 1024 due to the max length of string temp field
select doc.id, a from t3 group by doc.id having doc.id > 4444444444444444;
show warnings;


################################################################################
###
### General cases with JOIN, ORDER BY, SUB QUERY, etc.
###

--echo ##### General cases with JOIN, ORDER BY, SUB QUERY, etc.

### left join with CAST on document path
select t1.a, t1.doc.address.zipcode, t2.a2, t2.doc2.address.zipcode
from t2 left join t1
on cast(t1.doc.address.zipcode as unsigned) = cast(t2.doc2.address.zipcode as unsigned);

### left join without CAST on document path
select t1.a, t1.doc.address.zipcode, t2.a2, t2.doc2.address.zipcode
from t1, t2
where t1.doc.address.zipcode like t2.doc2.address.zipcode;


### left join with CAST on document path with ORDER BY with CAST
select t1.a, t1.doc.address.zipcode, t2.a2, t2.doc2.address.zipcode
from t2 right join t1
on cast(t1.doc.address.zipcode as unsigned) = cast(t2.doc2.address.zipcode as unsigned)
order by cast(t1.doc.address.zipcode as unsigned) asc, t1.a;


### left join without CAST on document path with ORDER BY without CAST
select t1.a, t1.doc.address.zipcode, t2.a2, t2.doc2.address.zipcode
from t2 right join t1
on t1.doc.address.zipcode like t2.doc2.address.zipcode
order by t1.doc.address.zipcode desc, t1.a, t2.a2;


################################################################################
###
### General cases with JOIN, ORDER BY, SUB QUERY, etc.
###
### FIXME:
###
###   SUB QUERY: without CAST, identical document field name in two tables will cause
###              conflicts on document paths from these tables, and alias doesn't work
###              properly.
###

--echo ##### General cases with JOIN, ORDER BY, SUB QUERY, etc.

### Aliases work well with CAST
select t1_name, t1_zipcode, t2_name, t2_zipcode
from (
  select cast(t1.doc.name as char) as t1_name, cast(t1.doc.address.zipcode as unsigned) as t1_zipcode,
         cast(t2.doc2.name as char) as t2_name, cast(t2.doc2.address.zipcode as unsigned) as t2_zipcode
  from t1, t2
  where cast(t1.doc.address.zipcode as unsigned) = cast(t2.doc2.address.zipcode as unsigned)
) as tmp
where t1_zipcode = 98761 or t2_zipcode = 98762;

### FIXME: Aliases don't work properly without CAST
select tmp.t1_zipcode, t2_zipcode
from (
  select t1.doc.address.zipcode as t1_zipcode, t2.doc2.address.zipcode as t2_zipcode
  from t1, t2
  where t1.doc.address.zipcode like t2.doc2.address.zipcode
) as tmp
where t1_zipcode like "98761" or tmp.t2_zipcode like "98762";


################################################################################
###
### Clean up
###

--echo ##### Clean up

# Restore the original value
SET @@global.allow_document_type = @start_allow_document_type;
SELECT @@global.allow_document_type;

drop table t1, t2, t3, t4, t5;

--source include/rpl_end.inc

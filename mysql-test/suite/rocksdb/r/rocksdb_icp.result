select * from information_schema.engines where engine = 'rocksdb';
ENGINE	SUPPORT	COMMENT	TRANSACTIONS	XA	SAVEPOINTS
ROCKSDB	YES	RocksDB storage engine	YES	YES	NO
drop table if exists t0,t1,t2,t3;
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1(a int);
insert into t1 select A.a + B.a* 10 + C.a * 100 from t0 A, t0 B, t0 C;
create table t2 (
pk int primary key,
kp1 int,
kp2 int,
col1 int,
key (kp1,kp2) comment 'cf1'
) engine=rocksdb;
insert into t2 select a,a,a,a from t1;
# Try a basic case:
explain 
select * from t2 where kp1 between 1 and 10 and mod(kp2,2)=0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	kp1	kp1	5	NULL	1	Using index condition
select * from t2 where kp1 between 1 and 10 and mod(kp2,2)=0;
pk	kp1	kp2	col1
2	2	2	2
4	4	4	4
6	6	6	6
8	8	8	8
10	10	10	10
# Check that ICP doesnt work for columns where column value 
# cant be restored from mem-comparable form:
create table t3 (
pk int primary key,
kp1 int,
kp2 varchar(10) collate utf8_general_ci,
col1 int,
key (kp1,kp2) comment 'cf1'
) engine=rocksdb;
insert into t3 select a,a/10,a,a from t1;
# This must not use ICP:
explain
select * from t3 where kp1=3 and kp2 like '%foo%';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	ref	kp1	kp1	5	const	1	Using where
explain format=json
select * from t3 where kp1 between 2 and 4 and mod(kp1,3)=0 and kp2 like '%foo%';
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t3",
      "access_type": "range",
      "possible_keys": [
        "kp1"
      ],
      "key": "kp1",
      "used_key_parts": [
        "kp1"
      ],
      "key_length": "5",
      "rows": 1,
      "filtered": 100,
      "index_condition": "((`test`.`t3`.`kp1` between 2 and 4) and ((`test`.`t3`.`kp1` % 3) = 0))",
      "attached_condition": "(`test`.`t3`.`kp2` like '%foo%')"
    }
  }
}
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`pk` AS `pk`,`test`.`t3`.`kp1` AS `kp1`,`test`.`t3`.`kp2` AS `kp2`,`test`.`t3`.`col1` AS `col1` from `test`.`t3` where ((`test`.`t3`.`kp1` between 2 and 4) and ((`test`.`t3`.`kp1` % 3) = 0) and (`test`.`t3`.`kp2` like '%foo%'))
# Check that we handle the case where out-of-range is encountered sooner
# than matched index condition
explain 
select * from t2 where kp1< 3 and kp2+1>50000;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	kp1	kp1	5	NULL	1	Using index condition
select * from t2 where kp1< 3 and kp2+1>50000;
pk	kp1	kp2	col1
explain
select * from t2 where kp1< 3 and kp2+1>50000;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	kp1	kp1	5	NULL	1	Using index condition
select * from t2 where kp1< 3 and kp2+1>50000;
pk	kp1	kp2	col1
# Try doing backwards scans
explain 
select * from t2 where kp1 between 1 and 10 and mod(kp2,2)=0 order by kp1 desc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	kp1	kp1	5	NULL	1	Using index condition
select * from t2 where kp1 between 1 and 10 and mod(kp2,2)=0 order by kp1 desc;
pk	kp1	kp2	col1
10	10	10	10
8	8	8	8
6	6	6	6
4	4	4	4
2	2	2	2
explain 
select * from t2 where kp1 >990 and mod(kp2,2)=0 order by kp1 desc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	kp1	kp1	5	NULL	1	Using index condition
select * from t2 where kp1 >990 and mod(kp2,2)=0 order by kp1 desc;
pk	kp1	kp2	col1
998	998	998	998
996	996	996	996
994	994	994	994
992	992	992	992
explain 
select * from t2 where kp1< 3 and kp2+1>50000 order by kp1 desc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	kp1	kp1	5	NULL	1	Using index condition
select * from t2 where kp1< 3 and kp2+1>50000 order by kp1 desc;
pk	kp1	kp2	col1
drop table t0,t1,t2,t3;
#
# Check how ICP affects counters
#
# First, some preparations
#
create procedure save_read_stats()
select ROWS_READ, ROWS_REQUESTED, ROWS_INDEX_FIRST, ROWS_INDEX_NEXT 
into @rr, @rq, @rif, @rin
from information_schema.table_statistics 
where table_name='t4' and table_schema=database();
create procedure get_read_stats()
select 
ROWS_READ-@rr, ROWS_REQUESTED-@rq, ROWS_INDEX_FIRST-@rif, ROWS_INDEX_NEXT-@rin
from information_schema.table_statistics 
where table_name='t4' and table_schema=database();
create table t4 (
id int, 
id1 int, 
id2 int, 
value int, 
value2 varchar(100), 
primary key (id), 
key id1_id2 (id1, id2) comment 'cf1'
) engine=rocksdb charset=latin1 collate latin1_bin;
insert into t4 values 
(1,1,1,1,1), (2,1,2,2,2), (3,1,3,3,3),(4,1,4,4,4),(5,1,5,5,5),
(6,1,6,6,6), (7,1,7,7,7), (8,1,8,8,8),(9,1,9,9,9),(10,1,10,10,10);
#
# Now, the test itself
#
call save_read_stats();
call get_read_stats();
ROWS_READ-@rr	ROWS_REQUESTED-@rq	ROWS_INDEX_FIRST-@rif	ROWS_INDEX_NEXT-@rin
0	0	0	0
# ============== index-only query ==============
explain
select id1,id2 from t4 force index (id1_id2) where id1=1 and id2 % 10 = 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t4	ref	id1_id2	id1_id2	5	const	1	Using where; Using index
call save_read_stats();
select id1,id2 from t4 force index (id1_id2) where id1=1 and id2 % 10 = 1;
id1	id2
1	1
call get_read_stats();
ROWS_READ-@rr	10
ROWS_REQUESTED-@rq	11
ROWS_INDEX_FIRST-@rif	1
ROWS_INDEX_NEXT-@rin	9
# ============== Query without ICP ==============
set optimizer_switch='index_condition_pushdown=off';
explain
select * from t4 force index (id1_id2) where id1=1 and id2 % 10 = 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t4	ref	id1_id2	id1_id2	5	const	1	Using where
call save_read_stats();
select * from t4 force index (id1_id2) where id1=1 and id2 % 10 = 1;
id	id1	id2	value	value2
1	1	1	1	1
call get_read_stats();
ROWS_READ-@rr	10
ROWS_REQUESTED-@rq	11
ROWS_INDEX_FIRST-@rif	1
ROWS_INDEX_NEXT-@rin	9
# ============== Query with ICP ==============
set optimizer_switch='index_condition_pushdown=on';
explain
select * from t4 force index (id1_id2) where id1=1 and id2 % 10 = 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t4	ref	id1_id2	id1_id2	5	const	1	Using index condition
call save_read_stats();
select * from t4 force index (id1_id2) where id1=1 and id2 % 10 = 1;
id	id1	id2	value	value2
1	1	1	1	1
call get_read_stats();
ROWS_READ-@rr	1
ROWS_REQUESTED-@rq	1
ROWS_INDEX_FIRST-@rif	1
ROWS_INDEX_NEXT-@rin	0
drop table t4;
drop procedure save_read_stats;
drop procedure get_read_stats;
#
# Issue #67: Inefficient index condition pushdown
#
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (
pk int not null primary key,
key1 bigint(20) unsigned,
col1 int,
key (key1)
) engine=rocksdb;
insert into t1 
select 
A.a+10*B.a+100*C.a,
A.a+10*B.a+100*C.a,
1234
from t0 A, t0 B, t0 C;
set @count=0;
explain 
select * from t1 where key1=1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	key1	key1	9	const	1	Using index condition
set @count_diff =(select (value - @count) from information_schema.rocksdb_perf_context 
where table_schema=database() and table_name='t1' and stat_type='INTERNAL_KEY_SKIPPED_COUNT');
select * from t1 where key1=1;
pk	key1	col1
1	1	1234
set @count_diff =(select (value - @count) from information_schema.rocksdb_perf_context 
where table_schema=database() and table_name='t1' and stat_type='INTERNAL_KEY_SKIPPED_COUNT');
# The following must be =1, or in any case not 999:
select @count_diff as "INTERNAL_KEY_SKIPPED_COUNT increment";
INTERNAL_KEY_SKIPPED_COUNT increment
1
drop table t0,t1;

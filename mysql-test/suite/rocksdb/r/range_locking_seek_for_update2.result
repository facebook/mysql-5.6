show variables like 'rocksdb_use_range_locking';
Variable_name	Value
rocksdb_use_range_locking	ON
create table t0(a int primary key);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (
pk int,
a int,
primary key (pk) comment 'rlsfu_test'
) engine=rocksdb;
insert into t1 (pk)
select
A.a + B.a*10 + C.a*100
from 
t0 A, t0 B, t0 C;
delete from t1 where pk<100;
connect  con1,localhost,root,,;
connection con1;
begin;
set debug_sync='rocksdb.locking_iter_scan SIGNAL about_to_lock_range WAIT_FOR spoiler_inserted';
select * from t1 where pk >=5 order by pk limit 5 for update;
connection default;
set debug_sync='now WAIT_FOR about_to_lock_range';
insert into t1 (pk) values 
(10),(20),(30),(40),(50);
set debug_sync='now SIGNAL spoiler_inserted';
connection con1;
pk	a
10	NULL
20	NULL
30	NULL
40	NULL
50	NULL
# This must return 1, no 5:
select lock_count from information_schema.rocksdb_trx
where thread_id=CONNECTION_ID();
lock_count
1
rollback;
disconnect con1;
connection default;
drop table t0, t1;
#
# A testcase for locking at the end of the scan
#
create table t1 (
pk int,
primary key (pk) comment 'rlsfu_test'
) engine=rocksdb;
connect  con1,localhost,root,,;
connection con1;
insert into t1 values (1), (10), (100);
begin;
select * from t1 for update;
pk
1
10
100
connection default;
select * from t1;
pk
1
10
100
insert into t1 values (150);
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.PRIMARY
connection con1;
rollback;
begin;
explain
select * from t1 order by pk desc for update;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	#	100.00	Backward index scan; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`pk` AS `pk` from `test`.`t1` order by `test`.`t1`.`pk` desc
select * from t1 order by pk desc for update;
pk
100
10
1
connection default;
select * from t1;
pk
1
10
100
insert into t1 values (0);
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.PRIMARY
disconnect con1;
connection default;
drop table t1;
set global rocksdb_enable_iterate_bounds=off;
#
# A testcase for locking at the end of the scan
#
create table t1 (
pk int,
primary key (pk) comment 'rlsfu_test'
) engine=rocksdb;
connect  con1,localhost,root,,;
connection con1;
insert into t1 values (1), (10), (100);
begin;
select * from t1 for update;
pk
1
10
100
connection default;
select * from t1;
pk
1
10
100
insert into t1 values (150);
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.PRIMARY
connection con1;
rollback;
begin;
explain
select * from t1 order by pk desc for update;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	#	100.00	Backward index scan; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`pk` AS `pk` from `test`.`t1` order by `test`.`t1`.`pk` desc
select * from t1 order by pk desc for update;
pk
100
10
1
connection default;
select * from t1;
pk
1
10
100
insert into t1 values (0);
ERROR HY000: Lock wait timeout exceeded; try restarting transaction: Timeout on index: test.t1.PRIMARY
disconnect con1;
connection default;
drop table t1;
set global rocksdb_enable_iterate_bounds=on;

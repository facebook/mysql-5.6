drop table if exists t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;
create table t0(a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1(a int);
insert into t1 select A.a + B.a* 10 + C.a * 100 from t0 A, t0 B, t0 C;
create table t2 (
pk int primary key,
col1 int,
filler char(32)
) engine=rocksdb;
insert into t2 select a,a,a from t1;
set global rocksdb_force_flush_memtable_now=1;
set @save_optimizer_switch=@@optimizer_switch;
set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';
explain 
select * from t2,t0 where t2.pk=t0.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	test.t0.a	1	Using join buffer (Batched Key Access)
select * from t2,t0 where t2.pk=t0.a;
pk	col1	filler	a
0	0	0	0
1	1	1	1
2	2	2	2
3	3	3	3
4	4	4	4
5	5	5	5
6	6	6	6
7	7	7	7
8	8	8	8
9	9	9	9
# This will use MRR:
explain select * from t2 where pk in (1,2,3,4,5);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	PRIMARY	PRIMARY	4	NULL	5	Using where; Using MRR
# Check how optimizer_switch flags effect it:
set optimizer_switch='mrr_cost_based=on';
# No MRR/BKA:
explain select * from t2,t0 where t2.pk=t0.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	test.t0.a	1	NULL
explain select * from t2 where pk in (1,2,3,4,5);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	PRIMARY	PRIMARY	4	NULL	5	Using where
set optimizer_switch='mrr_cost_based=off,mrr=off';
# No MRR/BKA:
explain select * from t2,t0 where t2.pk=t0.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	test.t0.a	1	NULL
explain select * from t2 where pk in (1,2,3,4,5);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	PRIMARY	PRIMARY	4	NULL	5	Using where
set optimizer_switch='mrr_cost_based=off,mrr=on';
# Have MRR/BKA:
explain select * from t2,t0 where t2.pk=t0.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	test.t0.a	1	Using join buffer (Batched Key Access)
explain select * from t2 where pk in (1,2,3,4,5);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	PRIMARY	PRIMARY	4	NULL	5	Using where; Using MRR
# This will not use MRR, as one of the ranges is a non-singlepoint:
explain select * from t2 where pk in (1,2,3,4,5) or pk between 6 and 8;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	PRIMARY	PRIMARY	4	NULL	6	Using where
create table t3 (
pk1 int,
pk2 int,
col1 int,
filler char(32),
primary key(pk1, pk2),
key(col1)
) engine=rocksdb;
insert into t3 select a,a, a,a from t1;
set global rocksdb_force_flush_memtable_now=1;
# This must not use BKA as it uses key prefix:
explain 
select * from t3,t0 where t3.pk1=t0.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t3	ref	PRIMARY	PRIMARY	4	test.t0.a	2	NULL
# This must not use BKA as it uses secondary index:
explain 
select * from t3,t0 where t3.col1=t0.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t3	ref	col1	col1	5	test.t0.a	4	NULL
# This will use BKA as it uses full key:
explain 
select * from t3,t0 where t3.pk1=t0.a and t3.pk2=t0.a+1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t3	eq_ref	PRIMARY	PRIMARY	8	test.t0.a,func	1	Using where; Using join buffer (Batched Key Access)
# This will use MRR as it uses full key:
explain select * from t3 where pk1 in (1,2,3,4,5) and pk2 in (3,4,5);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	range	PRIMARY	PRIMARY	8	NULL	15	Using where; Using MRR
# This will not use MRR as there are non-singlepoint ranges:
explain select * from t3 where (pk1 in (1,2,4,5) and pk2 in (4,5)) or pk1=3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	range	PRIMARY	PRIMARY	8	NULL	9	Using where
# Due to HA_MRR_SUPPORT_SORTED, the following will use MRR, and not require filesort:
explain select * from t3 where pk1 in (1,2,3,4,5) and pk2 in (3,4,5) order by pk1, pk2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	range	PRIMARY	PRIMARY	8	NULL	15	Using where; Using MRR
# Test for lookups returning nothing
delete from t2 where pk in (3,5,7,9,10) or pk between 100 and 200;
explain
select * from t2,t0 where t2.pk=t0.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	test.t0.a	1	Using join buffer (Batched Key Access)
select * from t2,t0 where t2.pk=t0.a;
pk	col1	filler	a
0	0	0	0
1	1	1	1
2	2	2	2
4	4	4	4
6	6	6	6
8	8	8	8
# Test for a scan returning nothing at all:
explain
select * from t2,t0 where t2.pk=t0.a+500100;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	10	NULL
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	func	1	Using where; Using join buffer (Batched Key Access)
select * from t2,t0 where t2.pk=t0.a+500100;
pk	col1	filler	a
# Make the scan finish before it has returned all the data:
select * from t2,t0 where t2.pk=t0.a limit 1;
pk	col1	filler	a
0	0	0	0
# Re-execute MRR scan in a subquery:
create table t4(a int primary key);
insert into t4 values (4),(6),(8);
explain
select a ,
(select concat(t0.a,'-',t2.pk) 
from t2,t0 
where t2.pk=t0.a and t2.col1>=t4.a
limit 1) as SUBQ
from t4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	index	NULL	PRIMARY	4	NULL	#	Using index
2	DEPENDENT SUBQUERY	t0	ALL	NULL	NULL	NULL	NULL	#	Using where
2	DEPENDENT SUBQUERY	t2	eq_ref	PRIMARY	PRIMARY	4	test.t0.a	#	Using where; Using join buffer (Batched Key Access)
select a ,
(select concat(t0.a,'-',t2.pk) 
from t2,t0 
where t2.pk=t0.a and t2.col1>=t4.a
limit 1) as SUBQ
from t4;
a	SUBQ
4	4-4
6	6-6
8	8-8
drop table t0,t1,t2,t3,t4;
set optimizer_switch=@save_optimizer_switch;

#
# Some basic sanity tests for deadlock detection.
#
--source include/have_rocksdb.inc

set @prior_rocksdb_lock_wait_timeout = @@rocksdb_lock_wait_timeout;
set @prior_rocksdb_deadlock_detect = @@rocksdb_deadlock_detect;
set global rocksdb_lock_wait_timeout = 100000;
set global rocksdb_deadlock_detect = ON;

create table t (i int primary key);

connect (con1,localhost,root,,);
begin;
insert into t values (1);

connect (con2,localhost,root,,);
begin;
insert into t values (2);

connect (con3,localhost,root,,);
begin;
insert into t values (3);

connection con1;
--send select * from t where i = 2 for update

connection con2;
let $wait_condition =
select count(*) = 1 as c from information_schema.processlist where
state = "Waiting for row lock" and
info = "select * from t where i = 2 for update";
--source include/wait_condition.inc

--send select * from t where i = 3 for update

connection con3;
let $wait_condition =
select count(*) = 1 as c from information_schema.processlist where
state = "Waiting for row lock" and
info = "select * from t where i = 3 for update";
--source include/wait_condition.inc

select * from t;
--error ER_LOCK_DEADLOCK
insert into t values (4), (1);
--echo # Statement should be rolled back
select * from t;

connection default;
disconnect con1;
disconnect con2;
disconnect con3;

set global rocksdb_lock_wait_timeout = @prior_rocksdb_lock_wait_timeout;
set global rocksdb_deadlock_detect = @prior_rocksdb_deadlock_detect;
drop table t;

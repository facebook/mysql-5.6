

A concurrent test for Range Locking code

== Requirements ==

The idea is to have a concurrent workload, where
- Some clients make modifications to the database that use range locking (let's
  denote these RL-UPDATES)

- There is some concurrent data modification activity, which is likely to
  make RL-UPDATES corrupt the data if transaction isolation does not perform
  proper range locking

- There is a way to detect this data corruption. First suggestion: have some
  invariants that must remain true regardless of any action done by
  RL-UPDATES. We can run the workload, then stop it and verify the invariants
  still hold.

== Suggestion ==

Rows and groups.

Consider a table:

create table t1 (
  pk bigint primary key,
  group_list varchar(128),
  parent_id bigint
) engine=rocksdb;


We allow the following to be stored:

1. Individual rows. An individual row has group_list=NULL, parent_id=NULL.

2. Groups.

A group is 5 (or some other number) of rows with adjacent PK values.

The row with the smallest PK value is the "group leader" and has
group_list=(comma-separated-list-of-pks-of-group members).

The rest of the rows are "followers" and have parent_id=$GROUP_LEADER.pk

Example of a group:

mysql> select * from t1 where pk>=720418192 order by pk limit 5;
+-----------+---------------------------------------------------+-----------+
| pk        | group_list                                        | parent_id |
+-----------+---------------------------------------------------+-----------+
| 720418192 | 720418192,721972360,730798130,741595383,742883456 |      NULL |
| 721972360 | NULL                                              | 720418192 |
| 730798130 | NULL                                              | 720418192 |
| 741595383 | NULL                                              | 720418192 |
| 742883456 | NULL                                              | 720418192 |
+-----------+---------------------------------------------------+-----------+
5 rows in set (0.01 sec)


Operations:
- Insert an individual row. It is obvious we may not insert a row into a group.

- Convert 5 individual rows into a group. One needs range locking to prevent
  concurrent inserts.

- Disband a group (convert it back into 5 individual rows).


=== Implementation ===

range_locking_conc_test.py implements these operations

- Insert an individual row. This makes sure it doesn't break any group.

- create a group.  This does multiple things:
  1. Gets a sequence of 5 rows that doesn't start with a group member
  2. if it finds a group leader there, verify that group and disband it.
  3. Create a new group from the 5 rows we've got at step #1.




drop table if exists t0, t1, t2, t3;
create table t0 (id integer, x integer) engine=INNODB;
insert into t0 values(0, 0), (1, 1), (2, 2), (3, 3);
create table t1 (id integer primary key, x integer) engine=INNODB;
insert into t1 values(0, 0), (1, 1), (2, 2), (3, 3);
create table t2 (id integer primary key, x integer, unique key x(x)) engine=INNODB;
insert into t2 values(0, 0), (1, 1), (2, 2), (3, 3);
create table t3 (id integer primary key, x integer, key x(x)) engine=INNODB;
insert into t3 values(0, 0), (1, 1), (2, 2), (3, 3);
### (0.1) Without pirmary key: Locks on all rows
set autocommit=0;
SELECT * from t0 where id = 1 FOR UPDATE;
id	x
1	1
set autocommit=0;
lock will skip
SELECT * from t0 where id >= 0 FOR UPDATE SKIP LOCKED;
id	x
lock will skip
SELECT * from t0 order by id FOR UPDATE SKIP LOCKED;
id	x
lock will not wait, expecting error
SELECT * from t0 where id = 1 FOR UPDATE NOWAIT;
ERROR HY000: Failed to lock a record and didn't wait
commit;
commit;
### (0.2) Without pirmary key: Locks on some rows with 'limit x'
set autocommit=0;
SELECT * from t0 where id = 1 limit 1 FOR UPDATE;
id	x
1	1
set autocommit=0;
lock will skip
SELECT * from t0 where id >= 0 FOR UPDATE SKIP LOCKED;
id	x
2	2
3	3
lock will skip
SELECT * from t0 order by id FOR UPDATE SKIP LOCKED;
id	x
2	2
3	3
lock will not wait, expecting error
SELECT * from t0 where id = 1 FOR UPDATE NOWAIT;
ERROR HY000: Failed to lock a record and didn't wait
commit;
commit;
### (1) With pirmary key: Locks only on the record (covering index)
set autocommit=0;
SELECT * from t1 where id = 1 FOR UPDATE;
id	x
1	1
set autocommit=0;
lock will skip
SELECT * from t1 where id >= 0 FOR UPDATE SKIP LOCKED;
id	x
0	0
2	2
3	3
lock will skip
SELECT * from t1 order by id FOR UPDATE SKIP LOCKED;
id	x
0	0
2	2
3	3
lock will not wait, expecting error
SELECT * from t1 where id = 1 FOR UPDATE NOWAIT;
ERROR HY000: Failed to lock a record and didn't wait
commit;
commit;
### (2) With unique secondary key: Locks on the unique secondary key (covering index)
set autocommit=0;
SELECT x from t2 where x = 1 FOR UPDATE;
x
1
set autocommit=0;
lock will skip
SELECT x from t2 where x >= 0 FOR UPDATE SKIP LOCKED;
x
0
2
3
lock will skip
SELECT x from t2 order by x FOR UPDATE SKIP LOCKED;
x
0
2
3
lock will not wait, expecting error
SELECT x from t2 where x = 1 FOR UPDATE NOWAIT;
ERROR HY000: Failed to lock a record and didn't wait
commit;
commit;
### (3) With unique secondary key: Locks on the unique secondary key (covering index)
set autocommit=0;
SELECT x from t3 where x = 1 FOR UPDATE;
x
1
set autocommit=0;
lock will skip
SELECT x from t3 where x >= 0 FOR UPDATE SKIP LOCKED;
x
0
2
3
lock will skip
SELECT x from t3 order by x FOR UPDATE SKIP LOCKED;
x
0
2
3
lock will not wait, expecting error
SELECT x from t3 where x = 1 FOR UPDATE NOWAIT;
ERROR HY000: Failed to lock a record and didn't wait
commit;
commit;
### (4) Locks on both the primary key and the unique secondary key
set autocommit=0;
SELECT * from t2 where id = 1 FOR UPDATE;
id	x
1	1
set autocommit=0;
lock will skip
SELECT * from t2 where id >= 0 FOR UPDATE SKIP LOCKED;
id	x
0	0
2	2
3	3
lock will skip
SELECT * from t2 order by id FOR UPDATE SKIP LOCKED;
id	x
0	0
2	2
3	3
lock will not wait, expecting error
SELECT * from t2 where id = 1 FOR UPDATE NOWAIT;
ERROR HY000: Failed to lock a record and didn't wait
commit;
commit;
drop table t0, t1, t2, t3;
